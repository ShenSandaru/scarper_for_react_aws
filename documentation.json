[
    {
        "title": "Installation",
        "source": "react",
        "url": "https://react.dev/learn/installation",
        "sections": [
            "Learn ReactInstallationReact has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started. In this chapter How to start a new React project How to add React to an existing project How to set up your editor How to install React Developer Tools  Try React  You don\u2019t need to install anything to play with React. Try editing this sandbox! App.jsApp.js Download ResetFork912345678function Greeting({ name }) { return <h1>Hello, {name}</h1>;}export default function App() { return <Greeting name=\"world\" />}Open on CodeSandboxOpen Sandbox You can edit it directly or open it in a new tab by pressing the \u201cFork\u201d button in the upper right corner. Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example, CodeSandbox, StackBlitz, or CodePen. Try React locally  To try React locally on your computer, download this HTML page. Open it in your editor and in your browser! Start a new React project  If you want to build an app or a website fully with React, start a new React project. Add React to an existing project  If want to try using React in your existing app or a website, add React to an existing project. Next steps  Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day.PreviousThinking in ReactNextStart a New React Project"
        ]
    },
    {
        "title": "Describing the UI",
        "source": "react",
        "url": "https://react.dev/learn/describing-the-ui",
        "sections": [
            "Learn ReactDescribing the UIReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable components. From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you\u2019ll learn to create, customize, and conditionally display React components. In this chapter How to write your first React component When and how to create multi-component files How to add markup to JavaScript with JSX How to use curly braces with JSX to access JavaScript functionality from your components How to configure components with props How to conditionally render components How to render multiple components at a time How to avoid confusing bugs by keeping components pure Why understanding your UI as trees is useful  Your first component  React applications are built from isolated pieces of UI called components. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a Gallery component rendering three Profile components: App.jsApp.js Download ResetFork991234567891011121314151617181920function Profile() { return ( <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /> );}export default function Gallery() { return ( <section> <h1>Amazing scientists</h1> <Profile /> <Profile /> <Profile /> </section> );}Show more Ready to learn this topic?Read Your First Component to learn how to declare and use React components.Read More Importing and exporting components  You can declare many components in one file, but large files can get difficult to navigate. To solve this, you can export a component into its own file, and then import that component from another file: Gallery.jsProfile.jsGallery.js ResetForkimport Profile from './Profile.js';  export default function Gallery() {   return (     <section>       <h1>Amazing scientists</h1>       <Profile />       <Profile />       <Profile />     </section>   ); }   Ready to learn this topic?Read Importing and Exporting Components to learn how to split components into their own files.Read More Writing markup with JSX  Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. If we paste existing HTML markup into a React component, it won\u2019t always work: App.jsApp.js Download ResetForkexport default function TodoList() {   return (     // This doesn't quite work!     <h1>Hedy Lamarr's Todos</h1>     <img       src=\"https://i.imgur.com/yXOvdOSs.jpg\"       alt=\"Hedy Lamarr\"       class=\"photo\"     >     <ul>       <li>Invent new traffic lights       <li>Rehearse a movie scene       <li>Improve spectrum technology     </ul>  Show more If you have existing HTML like this, you can fix it using a converter: App.jsApp.js Download ResetForkexport default function TodoList() {   return (     <>       <h1>Hedy Lamarr's Todos</h1>       <img         src=\"https://i.imgur.com/yXOvdOSs.jpg\"         alt=\"Hedy Lamarr\"         className=\"photo\"       />       <ul>         <li>Invent new traffic lights</li>         <li>Rehearse a movie scene</li>         <li>Improve spectrum technology</li>       </ul>     </>   ); }  Show more Ready to learn this topic?Read Writing Markup with JSX to learn how to write valid JSX.Read More JavaScript in JSX with curly braces  JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to \u201copen a window\u201d to JavaScript: App.jsApp.js Download ResetForkconst person = {   name: 'Gregorio Y. Zara',   theme: {     backgroundColor: 'black',     color: 'pink'   } };  export default function TodoList() {   return (     <div style={person.theme}>       <h1>{person.name}'s Todos</h1>       <img         className=\"avatar\"         src=\"https://i.imgur.com/7vQD0fPs.jpg\"         alt=\"Gregorio Y. Zara\"       />       <ul>         <li>Improve the videophone</li>         <li>Prepare aeronautics lectures</li>         <li>Work on the alcohol-fuelled engine</li>       </ul>     </div>   ); }  Show more Ready to learn this topic?Read JavaScript in JSX with Curly Braces to learn how to access JavaScript data from JSX.Read More Passing props to a component  React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX! App.jsutils.jsApp.js ResetForkimport { getImageUrl } from './utils.js'  export default function Profile() {   return (     <Card>       <Avatar         size={100}         person={{           name: 'Katsuko Saruhashi',           imageId: 'YfeOqp2'         }}       />     </Card>   ); }  function Avatar({ person, size }) {   return (     <img       className=\"avatar\"       src={getImageUrl(person)}       alt={person.name}       width={size}       height={size}     />   ); }  function Card({ children }) {   return (     <div className=\"card\">       {children}     </div>   ); }  Show more Ready to learn this topic?Read Passing Props to a Component to learn how to pass and read props.Read More Conditional rendering  Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators. In this example, the JavaScript && operator is used to conditionally render a checkmark: App.jsApp.js Download ResetForkfunction Item({ name, isPacked }) {   return (     <li className=\"item\">       {name} {isPacked && '\u2705'}     </li>   ); }  export default function PackingList() {   return (     <section>       <h1>Sally Ride's Packing List</h1>       <ul>         <Item           isPacked={true}           name=\"Space suit\"         />         <Item           isPacked={true}           name=\"Helmet with a golden leaf\"         />         <Item           isPacked={false}           name=\"Photo of Tam\"         />       </ul>     </section>   ); }  Show more Ready to learn this topic?Read Conditional Rendering to learn the different ways to render content conditionally.Read More Rendering lists  You will often want to display multiple similar components from a collection of data. You can use JavaScript\u2019s filter() and map() with React to filter and transform your array of data into an array of components. For each array item, you will need to specify a key. Usually, you will want to use an ID from the database as a key. Keys let React keep track of each item\u2019s place in the list even if the list changes. App.jsdata.jsutils.jsApp.js ResetForkimport { people } from './data.js'; import { getImageUrl } from './utils.js';  export default function List() {   const listItems = people.map(person =>     <li key={person.id}>       <img         src={getImageUrl(person)}         alt={person.name}       />       <p>         <b>{person.name}:</b>         {' ' + person.profession + ' '}         known for {person.accomplishment}       </p>     </li>   );   return (     <article>       <h1>Scientists</h1>       <ul>{listItems}</ul>     </article>   ); }  Show more Ready to learn this topic?Read Rendering Lists to learn how to render a list of components, and how to choose a key.Read More Keeping components pure  Some JavaScript functions are pure. A pure function:  Minds its own business. It does not change any objects or variables that existed before it was called. Same inputs, same output. Given the same inputs, a pure function should always return the same result.  By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component: App.jsApp.js Download ResetForklet guest = 0;  function Cup() {   // Bad: changing a preexisting variable!   guest = guest + 1;   return <h2>Tea cup for guest #{guest}</h2>; }  export default function TeaSet() {   return (     <>       <Cup />       <Cup />       <Cup />     </>   ); }  Show more You can make this component pure by passing a prop instead of modifying a preexisting variable: App.jsApp.js Download ResetForkfunction Cup({ guest }) {   return <h2>Tea cup for guest #{guest}</h2>; }  export default function TeaSet() {   return (     <>       <Cup guest={1} />       <Cup guest={2} />       <Cup guest={3} />     </>   ); }   Ready to learn this topic?Read Keeping Components Pure to learn how to write components as pure, predictable functions.Read More Your UI as a tree  React uses trees to model the relationships between components and modules. A React render tree is a representation of the parent and child relationship between components. An example React render tree. Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance. Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree. An example module dependency tree. A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues. Ready to learn this topic?Read Your UI as a Tree to learn how to create a render and module dependency trees for a React app and how they\u2019re useful mental models for improving user experience and performance.Read More What\u2019s next?  Head over to Your First Component to start reading this chapter page by page! Or, if you\u2019re already familiar with these topics, why not read about Adding Interactivity?NextYour First Component"
        ]
    },
    {
        "title": "Adding Interactivity",
        "source": "react",
        "url": "https://react.dev/learn/adding-interactivity",
        "sections": [
            "Learn ReactAdding InteractivitySome things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is called state. You can add state to any component, and update it as needed. In this chapter, you\u2019ll learn how to write components that handle interactions, update their state, and display different output over time. In this chapter How to handle user-initiated events How to make components \u201cremember\u201d information with state How React updates the UI in two phases Why state doesn\u2019t update right after you change it How to queue multiple state updates How to update an object in state How to update an array in state  Responding to events  React lets you add event handlers to your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on. Built-in components like <button> only support built-in browser events like onClick. However, you can also create your own components, and give their event handler props any application-specific names that you like. App.jsApp.js Download ResetFork99123456789101112131415161718192021222324252627282930export default function App() { return ( <Toolbar onPlayMovie={() => alert('Playing!')} onUploadImage={() => alert('Uploading!')} /> );}function Toolbar({ onPlayMovie, onUploadImage }) { return ( <div> <Button onClick={onPlayMovie}>        Play Movie </Button> <Button onClick={onUploadImage}>        Upload Image </Button> </div> );}function Button({ onClick, children }) { return ( <button onClick={onClick}> {children} </button> );}Show more Ready to learn this topic?Read Responding to Events to learn how to add event handlers.Read More State: a component\u2019s memory  Components often need to change what\u2019s on the screen as a result of an interaction. Typing into the form should update the input field, clicking \u201cnext\u201d on an image carousel should change which image is displayed, clicking \u201cbuy\u201d puts a product in the shopping cart. Components need to \u201cremember\u201d things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state. You can add state to a component with a useState Hook. Hooks are special functions that let your components use React features (state is one of those features). The useState Hook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it. const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false); Here is how an image gallery uses and updates state on click: App.jsdata.jsApp.js ResetForkimport { useState } from 'react'; import { sculptureList } from './data.js';  export default function Gallery() {   const [index, setIndex] = useState(0);   const [showMore, setShowMore] = useState(false);   const hasNext = index < sculptureList.length - 1;    function handleNextClick() {     if (hasNext) {       setIndex(index + 1);     } else {       setIndex(0);     }   }    function handleMoreClick() {     setShowMore(!showMore);   }    let sculpture = sculptureList[index];   return (     <>       <button onClick={handleNextClick}>         Next       </button>       <h2>         <i>{sculpture.name} </i>         by {sculpture.artist}       </h2>       <h3>         ({index + 1} of {sculptureList.length})       </h3>       <button onClick={handleMoreClick}>         {showMore ? 'Hide' : 'Show'} details       </button>       {showMore && <p>{sculpture.description}</p>}       <img         src={sculpture.url}         alt={sculpture.alt}       />     </>   ); }  Show more Ready to learn this topic?Read State: A Component\u2019s Memory to learn how to remember a value and update it on interaction.Read More Render and commit  Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior. Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:  Triggering a render (delivering the diner\u2019s order to the kitchen) Rendering the component (preparing the order in the kitchen) Committing to the DOM (placing the order on the table)  TriggerRenderCommitIllustrated by Rachel Lee Nabors Ready to learn this topic?Read Render and Commit to learn the lifecycle of a UI update.Read More State as a snapshot  Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first! console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0! This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press \u201cSend\u201d first and then change the recipient to Bob. Whose name will appear in the alert five seconds later? App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Form() {   const [to, setTo] = useState('Alice');   const [message, setMessage] = useState('Hello');    function handleSubmit(e) {     e.preventDefault();     setTimeout(() => {       alert(`You said ${message} to ${to}`);     }, 5000);   }    return (     <form onSubmit={handleSubmit}>       <label>         To:{' '}         <select           value={to}           onChange={e => setTo(e.target.value)}>           <option value=\"Alice\">Alice</option>           <option value=\"Bob\">Bob</option>         </select>       </label>       <textarea         placeholder=\"Message\"         value={message}         onChange={e => setMessage(e.target.value)}       />       <button type=\"submit\">Send</button>     </form>   ); }  Show more Ready to learn this topic?Read State as a Snapshot to learn why state appears \u201cfixed\u201d and unchanging inside the event handlers.Read More Queueing a series of state updates  This component is buggy: clicking \u201c+3\u201d increments the score only once. App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Counter() {   const [score, setScore] = useState(0);    function increment() {     setScore(score + 1);   }    return (     <>       <button onClick={() => increment()}>+1</button>       <button onClick={() => {         increment();         increment();         increment();       }}>+3</button>       <h1>Score: {score}</h1>     </>   ) }  Show more State as a Snapshot explains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. So score continues to be 0 right after you call setScore(score + 1). console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0 You can fix this by passing an updater function when setting state. Notice how replacing setScore(score + 1) with setScore(s => s + 1) fixes the \u201c+3\u201d button. This lets you queue multiple state updates. App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Counter() {   const [score, setScore] = useState(0);    function increment() {     setScore(s => s + 1);   }    return (     <>       <button onClick={() => increment()}>+1</button>       <button onClick={() => {         increment();         increment();         increment();       }}>+3</button>       <h1>Score: {score}</h1>     </>   ) }  Show more Ready to learn this topic?Read Queueing a Series of State Updates to learn how to queue a sequence of state updates.Read More Updating objects in state  State can hold any kind of JavaScript value, including objects. But you shouldn\u2019t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy. Usually, you will use the ... spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this: App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Form() {   const [person, setPerson] = useState({     name: 'Niki de Saint Phalle',     artwork: {       title: 'Blue Nana',       city: 'Hamburg',       image: 'https://i.imgur.com/Sd1AgUOm.jpg',     }   });    function handleNameChange(e) {     setPerson({       ...person,       name: e.target.value     });   }    function handleTitleChange(e) {     setPerson({       ...person,       artwork: {         ...person.artwork,         title: e.target.value       }     });   }    function handleCityChange(e) {     setPerson({       ...person,       artwork: {         ...person.artwork,         city: e.target.value       }     });   }    function handleImageChange(e) {     setPerson({       ...person,       artwork: {         ...person.artwork,         image: e.target.value       }     });   }    return (     <>       <label>         Name:         <input           value={person.name}           onChange={handleNameChange}         />       </label>       <label>         Title:         <input           value={person.artwork.title}           onChange={handleTitleChange}         />       </label>       <label>         City:         <input           value={person.artwork.city}           onChange={handleCityChange}         />       </label>       <label>         Image:         <input           value={person.artwork.image}           onChange={handleImageChange}         />       </label>       <p>         <i>{person.artwork.title}</i>         {' by '}         {person.name}         <br />         (located in {person.artwork.city})       </p>       <img         src={person.artwork.image}         alt={person.artwork.title}       />     </>   ); }  Show more If copying objects in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{   \"dependencies\": {     \"immer\": \"1.7.3\",     \"react\": \"latest\",     \"react-dom\": \"latest\",     \"react-scripts\": \"latest\",     \"use-immer\": \"0.5.1\"   },   \"scripts\": {     \"start\": \"react-scripts start\",     \"build\": \"react-scripts build\",     \"test\": \"react-scripts test --env=jsdom\",     \"eject\": \"react-scripts eject\"   },   \"devDependencies\": {} } Ready to learn this topic?Read Updating Objects in State to learn how to update objects correctly.Read More Updating arrays in state  Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array: App.jsApp.js Download ResetForkimport { useState } from 'react';  const initialList = [   { id: 0, title: 'Big Bellies', seen: false },   { id: 1, title: 'Lunar Landscape', seen: false },   { id: 2, title: 'Terracotta Army', seen: true }, ];  export default function BucketList() {   const [list, setList] = useState(     initialList   );    function handleToggle(artworkId, nextSeen) {     setList(list.map(artwork => {       if (artwork.id === artworkId) {         return { ...artwork, seen: nextSeen };       } else {         return artwork;       }     }));   }    return (     <>       <h1>Art Bucket List</h1>       <h2>My list of art to see:</h2>       <ItemList         artworks={list}         onToggle={handleToggle} />     </>   ); }  function ItemList({ artworks, onToggle }) {   return (     <ul>       {artworks.map(artwork => (         <li key={artwork.id}>           <label>             <input               type=\"checkbox\"               checked={artwork.seen}               onChange={e => {                 onToggle(                   artwork.id,                   e.target.checked                 );               }}             />             {artwork.title}           </label>         </li>       ))}     </ul>   ); }  Show more If copying arrays in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{   \"dependencies\": {     \"immer\": \"1.7.3\",     \"react\": \"latest\",     \"react-dom\": \"latest\",     \"react-scripts\": \"latest\",     \"use-immer\": \"0.5.1\"   },   \"scripts\": {     \"start\": \"react-scripts start\",     \"build\": \"react-scripts build\",     \"test\": \"react-scripts test --env=jsdom\",     \"eject\": \"react-scripts eject\"   },   \"devDependencies\": {} } Ready to learn this topic?Read Updating Arrays in State to learn how to update arrays correctly.Read More What\u2019s next?  Head over to Responding to Events to start reading this chapter page by page! Or, if you\u2019re already familiar with these topics, why not read about Managing State?PreviousYour UI as a TreeNextResponding to Events"
        ]
    },
    {
        "title": "Managing State",
        "source": "react",
        "url": "https://react.dev/learn/managing-state",
        "sections": [
            "Learn ReactManaging StateIntermediateAs your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you\u2019ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components. In this chapter How to think about UI changes as state changes How to structure state well How to \u201clift state up\u201d to share it between components How to control whether the state gets preserved or reset How to consolidate complex state logic in a function How to pass information without \u201cprop drilling\u201d How to scale state management as your app grows  Reacting to input with state  With React, you won\u2019t modify the UI from code directly. For example, you won\u2019t write commands like \u201cdisable the button\u201d, \u201cenable the button\u201d, \u201cshow the success message\u201d, etc. Instead, you will describe the UI you want to see for the different visual states of your component (\u201cinitial state\u201d, \u201ctyping state\u201d, \u201csuccess state\u201d), and then trigger the state changes in response to user input. This is similar to how designers think about UI. Here is a quiz form built using React. Note how it uses the status state variable to determine whether to enable or disable the submit button, and whether to show the success message instead. App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Form() {   const [answer, setAnswer] = useState('');   const [error, setError] = useState(null);   const [status, setStatus] = useState('typing');    if (status === 'success') {     return <h1>That's right!</h1>   }    async function handleSubmit(e) {     e.preventDefault();     setStatus('submitting');     try {       await submitForm(answer);       setStatus('success');     } catch (err) {       setStatus('typing');       setError(err);     }   }    function handleTextareaChange(e) {     setAnswer(e.target.value);   }    return (     <>       <h2>City quiz</h2>       <p>         In which city is there a billboard that turns air into drinkable water?       </p>       <form onSubmit={handleSubmit}>         <textarea           value={answer}           onChange={handleTextareaChange}           disabled={status === 'submitting'}         />         <br />         <button disabled={           answer.length === 0 ||           status === 'submitting'         }>           Submit         </button>         {error !== null &&           <p className=\"Error\">             {error.message}           </p>         }       </form>     </>   ); }  function submitForm(answer) {   // Pretend it's hitting the network.   return new Promise((resolve, reject) => {     setTimeout(() => {       let shouldError = answer.toLowerCase() !== 'lima'       if (shouldError) {         reject(new Error('Good guess but a wrong answer. Try again!'));       } else {         resolve();       }     }, 1500);   }); }  Show more Ready to learn this topic?Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset.Read More Choosing the state structure  Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn\u2019t contain redundant or duplicated information. If there\u2019s unnecessary state, it\u2019s easy to forget to update it, and introduce bugs! For example, this form has a redundant fullName state variable: App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Form() {   const [firstName, setFirstName] = useState('');   const [lastName, setLastName] = useState('');   const [fullName, setFullName] = useState('');    function handleFirstNameChange(e) {     setFirstName(e.target.value);     setFullName(e.target.value + ' ' + lastName);   }    function handleLastNameChange(e) {     setLastName(e.target.value);     setFullName(firstName + ' ' + e.target.value);   }    return (     <>       <h2>Let\u2019s check you in</h2>       <label>         First name:{' '}         <input           value={firstName}           onChange={handleFirstNameChange}         />       </label>       <label>         Last name:{' '}         <input           value={lastName}           onChange={handleLastNameChange}         />       </label>       <p>         Your ticket will be issued to: <b>{fullName}</b>       </p>     </>   ); }  Show more You can remove it and simplify the code by calculating fullName while the component is rendering: App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Form() {   const [firstName, setFirstName] = useState('');   const [lastName, setLastName] = useState('');    const fullName = firstName + ' ' + lastName;    function handleFirstNameChange(e) {     setFirstName(e.target.value);   }    function handleLastNameChange(e) {     setLastName(e.target.value);   }    return (     <>       <h2>Let\u2019s check you in</h2>       <label>         First name:{' '}         <input           value={firstName}           onChange={handleFirstNameChange}         />       </label>       <label>         Last name:{' '}         <input           value={lastName}           onChange={handleLastNameChange}         />       </label>       <p>         Your ticket will be issued to: <b>{fullName}</b>       </p>     </>   ); }  Show more This might seem like a small change, but many bugs in React apps are fixed this way. Ready to learn this topic?Read Choosing the State Structure to learn how to design the state shape to avoid bugs.Read More Sharing state between components  Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as \u201clifting state up\u201d, and it\u2019s one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children. App.jsApp.js Download ResetForkimport { useState } from 'react';  export default function Accordion() {   const [activeIndex, setActiveIndex] = useState(0);   return (     <>       <h2>Almaty, Kazakhstan</h2>       <Panel         title=\"About\"         isActive={activeIndex === 0}         onShow={() => setActiveIndex(0)}       >         With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.       </Panel>       <Panel         title=\"Etymology\"         isActive={activeIndex === 1}         onShow={() => setActiveIndex(1)}       >         The name comes from <span lang=\"kk-KZ\">\u0430\u043b\u043c\u0430</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang=\"la\">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.       </Panel>     </>   ); }  function Panel({   title,   children,   isActive,   onShow }) {   return (     <section className=\"panel\">       <h3>{title}</h3>       {isActive ? (         <p>{children}</p>       ) : (         <button onClick={onShow}>           Show         </button>       )}     </section>   ); }  Show more Ready to learn this topic?Read Sharing State Between Components to learn how to lift state up and keep components in sync.Read More Preserving and resetting state  When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React\u2019s automatic behavior works well enough. By default, React preserves the parts of the tree that \u201cmatch up\u201d with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person: App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js';  export default function Messenger() {   const [to, setTo] = useState(contacts[0]);   return (     <div>       <ContactList         contacts={contacts}         selectedContact={to}         onSelect={contact => setTo(contact)}       />       <Chat contact={to} />     </div>   ) }  const contacts = [   { name: 'Taylor', email: 'taylor@mail.com' },   { name: 'Alice', email: 'alice@mail.com' },   { name: 'Bob', email: 'bob@mail.com' } ];  Show more React lets you override the default behavior, and force a component to reset its state by passing it a different key, like <Chat key={email} />. This tells React that if the recipient is different, it should be considered a different Chat component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field\u2014even though you render the same component. App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js';  export default function Messenger() {   const [to, setTo] = useState(contacts[0]);   return (     <div>       <ContactList         contacts={contacts}         selectedContact={to}         onSelect={contact => setTo(contact)}       />       <Chat key={to.email} contact={to} />     </div>   ) }  const contacts = [   { name: 'Taylor', email: 'taylor@mail.com' },   { name: 'Alice', email: 'alice@mail.com' },   { name: 'Bob', email: 'bob@mail.com' } ];  Show more Ready to learn this topic?Read Preserving and Resetting State to learn the lifetime of state and how to control it.Read More Extracting state logic into a reducer  Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called \u201creducer\u201d. Your event handlers become concise because they only specify the user \u201cactions\u201d. At the bottom of the file, the reducer function specifies how the state should update in response to each action! App.jsApp.js ResetForkimport { useReducer } from 'react'; import AddTask from './AddTask.js'; import TaskList from './TaskList.js';  export default function TaskApp() {   const [tasks, dispatch] = useReducer(     tasksReducer,     initialTasks   );    function handleAddTask(text) {     dispatch({       type: 'added',       id: nextId++,       text: text,     });   }    function handleChangeTask(task) {     dispatch({       type: 'changed',       task: task     });   }    function handleDeleteTask(taskId) {     dispatch({       type: 'deleted',       id: taskId     });   }    return (     <>       <h1>Prague itinerary</h1>       <AddTask         onAddTask={handleAddTask}       />       <TaskList         tasks={tasks}         onChangeTask={handleChangeTask}         onDeleteTask={handleDeleteTask}       />     </>   ); }  function tasksReducer(tasks, action) {   switch (action.type) {     case 'added': {       return [...tasks, {         id: action.id,         text: action.text,         done: false       }];     }     case 'changed': {       return tasks.map(t => {         if (t.id === action.task.id) {           return action.task;         } else {           return t;         }       });     }     case 'deleted': {       return tasks.filter(t => t.id !== action.id);     }     default: {       throw Error('Unknown action: ' + action.type);     }   } }  let nextId = 3; const initialTasks = [   { id: 0, text: 'Visit Kafka Museum', done: true },   { id: 1, text: 'Watch a puppet show', done: false },   { id: 2, text: 'Lennon Wall pic', done: false } ];  Show more Ready to learn this topic?Read Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function.Read More Passing data deeply with context  Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it\u2014no matter how deep it is\u2014without passing it explicitly through props. Here, the Heading component determines its heading level by \u201casking\u201d the closest Section for its level. Each Section tracks its own level by asking the parent Section and adding one to it. Every Section provides information to all components below it without passing props\u2014it does that through context. App.jsSection.jsHeading.jsLevelContext.jsApp.js ResetForkimport Heading from './Heading.js'; import Section from './Section.js';  export default function Page() {   return (     <Section>       <Heading>Title</Heading>       <Section>         <Heading>Heading</Heading>         <Heading>Heading</Heading>         <Heading>Heading</Heading>         <Section>           <Heading>Sub-heading</Heading>           <Heading>Sub-heading</Heading>           <Heading>Sub-heading</Heading>           <Section>             <Heading>Sub-sub-heading</Heading>             <Heading>Sub-sub-heading</Heading>             <Heading>Sub-sub-heading</Heading>           </Section>         </Section>       </Section>     </Section>   ); }  Show more Ready to learn this topic?Read Passing Data Deeply with Context to learn about using context as an alternative to passing props.Read More Scaling up with reducer and context  Reducers let you consolidate a component\u2019s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state. App.jsTasksContext.jsAddTask.jsTaskList.jsApp.js ResetForkimport AddTask from './AddTask.js'; import TaskList from './TaskList.js'; import { TasksProvider } from './TasksContext.js';  export default function TaskApp() {   return (     <TasksProvider>       <h1>Day off in Kyoto</h1>       <AddTask />       <TaskList />     </TasksProvider>   ); }   Ready to learn this topic?Read Scaling Up with Reducer and Context to learn how state management scales in a growing app.Read More What\u2019s next?  Head over to Reacting to Input with State to start reading this chapter page by page! Or, if you\u2019re already familiar with these topics, why not read about Escape Hatches?PreviousUpdating Arrays in StateNextReacting to Input with State"
        ]
    },
    {
        "title": "Escape Hatches",
        "source": "react",
        "url": "https://react.dev/learn/escape-hatches",
        "sections": [
            "Learn ReactEscape HatchesAdvancedSome of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you\u2019ll learn the escape hatches that let you \u201cstep outside\u201d React and connect to external systems. Most of your application logic and data flow should not rely on these features. In this chapter How to \u201cremember\u201d information without re-rendering How to access DOM elements managed by React How to synchronize components with external systems How to remove unnecessary Effects from your components How an Effect\u2019s lifecycle is different from a component\u2019s How to prevent some values from re-triggering Effects How to make your Effect re-run less often How to share logic between components  Referencing values with refs  When you want a component to \u201cremember\u201d some information, but you don\u2019t want that information to trigger new renders, you can use a ref: const ref = useRef(0); Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through the ref.current property. App.jsApp.js Download ResetForkimport { useRef } from 'react';  export default function Counter() {   let ref = useRef(0);    function handleClick() {     ref.current = ref.current + 1;     alert('You clicked ' + ref.current + ' times!');   }    return (     <button onClick={handleClick}>       Click me!     </button>   ); }  Show more A ref is like a secret pocket of your component that React doesn\u2019t track. For example, you can use refs to store timeout IDs, DOM elements, and other objects that don\u2019t impact the component\u2019s rendering output. Ready to learn this topic?Read Referencing Values with Refs to learn how to use refs to remember information.Read More Manipulating the DOM with refs  React automatically updates the DOM to match your render output, so your components won\u2019t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React\u2014for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref: App.jsApp.js Download ResetForkimport { useRef } from 'react';  export default function Form() {   const inputRef = useRef(null);    function handleClick() {     inputRef.current.focus();   }    return (     <>       <input ref={inputRef} />       <button onClick={handleClick}>         Focus the input       </button>     </>   ); }  Show more Ready to learn this topic?Read Manipulating the DOM with Refs to learn how to access DOM elements managed by React.Read More Synchronizing with Effects  Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events, Effects let you run some code after rendering. Use them to synchronize your component with a system outside of React. Press Play/Pause a few times and see how the video player stays synchronized to the isPlaying prop value: App.jsApp.js Download ResetForkimport { useState, useRef, useEffect } from 'react';  function VideoPlayer({ src, isPlaying }) {   const ref = useRef(null);    useEffect(() => {     if (isPlaying) {       ref.current.play();     } else {       ref.current.pause();     }   }, [isPlaying]);    return <video ref={ref} src={src} loop playsInline />; }  export default function App() {   const [isPlaying, setIsPlaying] = useState(false);   return (     <>       <button onClick={() => setIsPlaying(!isPlaying)}>         {isPlaying ? 'Pause' : 'Play'}       </button>       <VideoPlayer         isPlaying={isPlaying}         src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"       />     </>   ); }  Show more Many Effects also \u201cclean up\u201d after themselves. For example, an Effect that sets up a connection to a chat server should return a cleanup function that tells React how to disconnect your component from that server: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js';  export default function ChatRoom() {   useEffect(() => {     const connection = createConnection();     connection.connect();     return () => connection.disconnect();   }, []);   return <h1>Welcome to the chat!</h1>; }   In development, React will immediately run and clean up your Effect one extra time. This is why you see \"\u2705 Connecting...\" printed twice. This ensures that you don\u2019t forget to implement the cleanup function. Ready to learn this topic?Read Synchronizing with Effects to learn how to synchronize components with external systems.Read More You Might Not Need An Effect  Effects are an escape hatch from the React paradigm. They let you \u201cstep outside\u201d of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component\u2019s state when some props or state change), you shouldn\u2019t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone. There are two common cases in which you don\u2019t need Effects:  You don\u2019t need Effects to transform data for rendering. You don\u2019t need Effects to handle user events.  For example, you don\u2019t need an Effect to adjust some state based on other state: function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // \ud83d\udd34 Avoid: redundant state and unnecessary Effect  const [fullName, setFullName] = useState('');  useEffect(() => {    setFullName(firstName + ' ' + lastName);  }, [firstName, lastName]);  // ...} Instead, calculate as much as you can while rendering: function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // \u2705 Good: calculated during rendering  const fullName = firstName + ' ' + lastName;  // ...} However, you do need Effects to synchronize with external systems. Ready to learn this topic?Read You Might Not Need an Effect to learn how to remove unnecessary Effects.Read More Lifecycle of reactive effects  Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. This Effect depends on the value of the roomId prop. Props are reactive values, which means they can change on a re-render. Notice that the Effect re-synchronizes (and re-connects to the server) if roomId changes: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js';  const serverUrl = 'https://localhost:1234';  function ChatRoom({ roomId }) {   useEffect(() => {     const connection = createConnection(serverUrl, roomId);     connection.connect();     return () => connection.disconnect();   }, [roomId]);    return <h1>Welcome to the {roomId} room!</h1>; }  export default function App() {   const [roomId, setRoomId] = useState('general');   return (     <>       <label>         Choose the chat room:{' '}         <select           value={roomId}           onChange={e => setRoomId(e.target.value)}         >           <option value=\"general\">general</option>           <option value=\"travel\">travel</option>           <option value=\"music\">music</option>         </select>       </label>       <hr />       <ChatRoom roomId={roomId} />     </>   ); }  Show more React provides a linter rule to check that you\u2019ve specified your Effect\u2019s dependencies correctly. If you forget to specify roomId in the list of dependencies in the above example, the linter will find that bug automatically. Ready to learn this topic?Read Lifecycle of Reactive Events to learn how an Effect\u2019s lifecycle is different from a component\u2019s.Read More Separating events from Effects  Under ConstructionThis section describes an experimental API that has not yet been released in a stable version of React. Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others. All code inside Effects is reactive. It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if either roomId or theme have changed: App.jschat.jsnotifications.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection, sendMessage } from './chat.js'; import { showNotification } from './notifications.js';  const serverUrl = 'https://localhost:1234';  function ChatRoom({ roomId, theme }) {   useEffect(() => {     const connection = createConnection(serverUrl, roomId);     connection.on('connected', () => {       showNotification('Connected!', theme);     });     connection.connect();     return () => connection.disconnect();   }, [roomId, theme]);    return <h1>Welcome to the {roomId} room!</h1> }  export default function App() {   const [roomId, setRoomId] = useState('general');   const [isDark, setIsDark] = useState(false);   return (     <>       <label>         Choose the chat room:{' '}         <select           value={roomId}           onChange={e => setRoomId(e.target.value)}         >           <option value=\"general\">general</option>           <option value=\"travel\">travel</option>           <option value=\"music\">music</option>         </select>       </label>       <label>         <input           type=\"checkbox\"           checked={isDark}           onChange={e => setIsDark(e.target.checked)}         />         Use dark theme       </label>       <hr />       <ChatRoom         roomId={roomId}         theme={isDark ? 'dark' : 'light'}        />     </>   ); }  Show more This is not ideal. You want to re-connect to the chat only if the roomId has changed. Switching the theme shouldn\u2019t re-connect to the chat! Move the code reading theme out of your Effect into an Effect Event: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { experimental_useEffectEvent as useEffectEvent } from 'react'; import { createConnection, sendMessage } from './chat.js'; import { showNotification } from './notifications.js';  const serverUrl = 'https://localhost:1234';  function ChatRoom({ roomId, theme }) {   const onConnected = useEffectEvent(() => {     showNotification('Connected!', theme);   });    useEffect(() => {     const connection = createConnection(serverUrl, roomId);     connection.on('connected', () => {       onConnected();     });     connection.connect();     return () => connection.disconnect();   }, [roomId]);    return <h1>Welcome to the {roomId} room!</h1> }  export default function App() {   const [roomId, setRoomId] = useState('general');   const [isDark, setIsDark] = useState(false);   return (     <>       <label>         Choose the chat room:{' '}         <select           value={roomId}           onChange={e => setRoomId(e.target.value)}         >           <option value=\"general\">general</option>           <option value=\"travel\">travel</option>           <option value=\"music\">music</option>         </select>       </label>       <label>         <input           type=\"checkbox\"           checked={isDark}           onChange={e => setIsDark(e.target.checked)}         />         Use dark theme       </label>       <hr />       <ChatRoom         roomId={roomId}         theme={isDark ? 'dark' : 'light'}        />     </>   ); }  Show more Code inside Effect Events isn\u2019t reactive, so changing the theme no longer makes your Effect re-connect. Ready to learn this topic?Read Separating Events from Effects to learn how to prevent some values from re-triggering Effects.Read More Removing Effect dependencies  When you write an Effect, the linter will verify that you\u2019ve included every reactive value (like props and state) that the Effect reads in the list of your Effect\u2019s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case. For example, this Effect depends on the options object which gets re-created every time you edit the input: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js';  const serverUrl = 'https://localhost:1234';  function ChatRoom({ roomId }) {   const [message, setMessage] = useState('');    const options = {     serverUrl: serverUrl,     roomId: roomId   };    useEffect(() => {     const connection = createConnection(options);     connection.connect();     return () => connection.disconnect();   }, [options]);    return (     <>       <h1>Welcome to the {roomId} room!</h1>       <input value={message} onChange={e => setMessage(e.target.value)} />     </>   ); }  export default function App() {   const [roomId, setRoomId] = useState('general');   return (     <>       <label>         Choose the chat room:{' '}         <select           value={roomId}           onChange={e => setRoomId(e.target.value)}         >           <option value=\"general\">general</option>           <option value=\"travel\">travel</option>           <option value=\"music\">music</option>         </select>       </label>       <hr />       <ChatRoom roomId={roomId} />     </>   ); }  Show more You don\u2019t want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of the options object inside the Effect so that the Effect only depends on the roomId string: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js';  const serverUrl = 'https://localhost:1234';  function ChatRoom({ roomId }) {   const [message, setMessage] = useState('');    useEffect(() => {     const options = {       serverUrl: serverUrl,       roomId: roomId     };     const connection = createConnection(options);     connection.connect();     return () => connection.disconnect();   }, [roomId]);    return (     <>       <h1>Welcome to the {roomId} room!</h1>       <input value={message} onChange={e => setMessage(e.target.value)} />     </>   ); }  export default function App() {   const [roomId, setRoomId] = useState('general');   return (     <>       <label>         Choose the chat room:{' '}         <select           value={roomId}           onChange={e => setRoomId(e.target.value)}         >           <option value=\"general\">general</option>           <option value=\"travel\">travel</option>           <option value=\"music\">music</option>         </select>       </label>       <hr />       <ChatRoom roomId={roomId} />     </>   ); }  Show more Notice that you didn\u2019t start by editing the dependency list to remove the options dependency. That would be wrong. Instead, you changed the surrounding code so that the dependency became unnecessary. Think of the dependency list as a list of all the reactive values used by your Effect\u2019s code. You don\u2019t intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code. Ready to learn this topic?Read Removing Effect Dependencies to learn how to make your Effect re-run less often.Read More Reusing logic with custom Hooks  React comes with built-in Hooks like useState, useContext, and useEffect. Sometimes, you\u2019ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application\u2019s needs. In this example, the usePointerPosition custom Hook tracks the cursor position, while useDelayedValue custom Hook returns a value that\u2019s \u201clagging behind\u201d the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor: App.jsusePointerPosition.jsuseDelayedValue.jsApp.js ResetForkimport { usePointerPosition } from './usePointerPosition.js'; import { useDelayedValue } from './useDelayedValue.js';  export default function Canvas() {   const pos1 = usePointerPosition();   const pos2 = useDelayedValue(pos1, 100);   const pos3 = useDelayedValue(pos2, 200);   const pos4 = useDelayedValue(pos3, 100);   const pos5 = useDelayedValue(pos4, 50);   return (     <>       <Dot position={pos1} opacity={1} />       <Dot position={pos2} opacity={0.8} />       <Dot position={pos3} opacity={0.6} />       <Dot position={pos4} opacity={0.4} />       <Dot position={pos5} opacity={0.2} />     </>   ); }  function Dot({ position, opacity }) {   return (     <div style={{       position: 'absolute',       backgroundColor: 'pink',       borderRadius: '50%',       opacity,       transform: `translate(${position.x}px, ${position.y}px)`,       pointerEvents: 'none',       left: -20,       top: -20,       width: 40,       height: 40,     }} />   ); }  Show more You can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you\u2019ll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community. Ready to learn this topic?Read Reusing Logic with Custom Hooks to learn how to share logic between components.Read More What\u2019s next?  Head over to Referencing Values with Refs to start reading this chapter page by page!PreviousScaling Up with Reducer and ContextNextReferencing Values with Refs"
        ]
    },
    {
        "title": "What is AWS Lambda?",
        "source": "aws_lambda",
        "url": "https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html",
        "sections": [
            "Contact UsEnglishCreate an AWS AccountFeedback Preferences AWS LambdaDeveloper GuideWhat is AWS Lambda?Create your first functionExample appsFile-processing appScheduled-maintenance appKey Lambda conceptsInfrastructure as code (IaC)Using the AWS CDKProgramming modelLambda runtimesRuntime version updatesConfiguring runtime managementRuntime version roll-backIdentifying Lambda runtime version changesShared responsibility modelPermissionsGet data about functions by runtimeRuntime modificationsRuntime APIOS-only runtimesBuilding a custom runtimeCustom runtime tutorialExecution environmentConfiguring functions.zip file archivesEncryptionContainer imagesMemoryEphemeral storageInstruction sets (ARM/x86)TimeoutEnvironment variablesSecuring environment variablesRetrieving environment variablesAttaching functions to a VPCAttaching functions to resources in another accountInternet access for VPC functionsInbound networkingFile systemAliasesUsing aliasesRouting configurationsVersionsTagsResponse streamingWriting functionsInvoking functionsTutorial: Creating a response streaming function with a function URLInvoking functionsInvoke a function synchronouslyAsynchronous invocationError handlingConfigurationRetaining recordsEvent source mappingsEvent source mapping tagsEvent filteringTesting in consoleFunction statesRetriesRecursive loop detectionFunction URLsAccess controlInvoking function URLsMonitoring function URLsSelect an HTTP invoke method for LambdaTutorial: Creating a function with a function URLFunction scalingConfiguring reserved concurrencyConfiguring provisioned concurrencyScaling behaviorMonitoring concurrencyBuilding with Node.jsHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with TypeScriptHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with PythonHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTestingTracingBuilding with RubyHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with JavaHandlerDeploy .zip file archivesDeploy container imagesLayersCustom serializationCustom startup behaviorContextLoggingTracingSample appsBuilding with GoHandlerContextDeploy .zip file archivesDeploy container imagesLayersLoggingTracingBuilding with C#HandlerDeployment packageNET Lambda Global CLIAWS SAMAWS CDKASP.NETDeploy container imagesNative AOT compilationContextLoggingTracingTestingBuilding with PowerShellDevelopment EnvironmentDeployment packageHandlerContextLoggingBuilding with RustHandlerContextHTTP eventsDeploy .zip file archivesLoggingBest practicesTesting serverless functionsLambda SnapStartActivating SnapStartHandling uniquenessRuntime hooksJavaPython.NETMonitoringSecurity modelBest practicesTroubleshootingIntegrating other servicesApache KafkaConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTroubleshootingAPI GatewayTutorialErrorsSelect an HTTP invoke method for LambdaInfrastructure ComposerCloudFormationAmazon DocumentDBTutorialDynamoDBCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialEC2Elastic Load Balancing (Application Load Balancer)Invoke using an EventBridge SchedulerIoTKinesis Data StreamsCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialMQConfigure event sourceParametersEvent filteringTroubleshootMSKConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTutorialRDSS3Tutorial: Use an S3 triggerTutorial: Use an Amazon S3 trigger to create thumbnailsSQSCreate mappingScaling behaviorError handlingParametersEvent filteringTutorialSQS cross-account tutorialS3 BatchSNSTutorialLambda permissionsExecution role (permissions for functions to access other resources)Update execution roleAWS managed policiesSource function ARNAccess permissions (permissions for other entities to access your functions)Identity-based policiesFunction accessLayer accessResource-based policiesFunction access for AWS servicesFunction access for AWS OrganizationsFunction access for other accountsLayer access for other accountsAttribute-based access controlSecure your functions by tagResources and ConditionsSecurity, governance, and complianceData protectionEncryption at restIdentity and Access ManagementHow AWS Lambda works with IAMIdentity-based policy examplesAWS managed policiesTroubleshootingGovernanceProactive controls with GuardProactive controls with AWS ConfigDetective controls with AWS ConfigCode signingCode scanningObservabilityCompliance validationResilienceInfrastructure securityCode signingCreate configurationUpdate configurationPermissionsCode signing configuration tagsMonitoring functionsFunction metricsView function metricsMetric typesFunction logsConfigure function logsView function logsCloudTrail logsAWS X-RayFunction insightsApplication SignalsLambda layersPackaging layersCreating and deleting layersAdding layersLayers with AWS CloudFormationLayers with AWS SAMLambda extensionsConfiguring extensionsExtensions partnersExtensions APITelemetry APIAPI referenceEvent schema referenceConverting events to OTel SpansLogs APITroubleshootingDeploymentInvocationExecutionNetworkingLambda applicationsMonitoring applicationsRolling deploymentsKubernetesSample applicationsWorking with AWS SDKsCode examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examplesConnecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS triggerLambda quotasOperator GuideIntroductionEvent-driven architecturesHow Lambda fits into the event-driven paradigmThe benefits of event-driven architecturesTrade-offs of event-driven architecturesDesign principlesUse services instead of custom codeUnderstanding the level of abstractionImplementing statelessness in functionsLambda function designBuilding for on-demand data instead of batchesOrchestrationDeveloping for retries and failuresAnti-patterns in Lambda-based applicationsThe Lambda monolithLambda as orchestratorRecursive patterns that cause run-away Lambda functionsLambda functions calling Lambda functionsSynchronous waiting within a single Lambda functionFrequently asked questionsApplication designUnderstanding quotasArchitecting with Service QuotasUsing multiple AWS accounts for managing quotasScaling and concurrency in LambdaChoosing and managing runtimes in Lambda functionsRuntimes and performanceMultiple runtimes in single applicationsManaging AWS SDKs in Lambda functionsNetworking and VPC configurationsComparing Lambda invocation modesUnderstanding SQS retriesControlling traffic flow for server-based resourcesFrequently asked questionsSecurityUnderstanding the Lambda execution environmentApplying the principles of least privilegeDeveloping least privilege IAM rolesAccess to CloudWatch LogsAvoiding granting wildcard permissions in IAM policiesSpecialized Lambda functions compared with all-purpose functionsSecuring workloads with public endpointsEncrypting data in Lambda-based applicationsGovernance controls with AWS CloudTrailFrequently asked questionsDebuggingStandardizing a debugging approachGeneral types of errorTroubleshooting payloadsTroubleshooting integration errorsTroubleshooting Lambda configurationsTroubleshooting queue processing by Lambda functionsIdentifying and managing throttlingErrors in the processing functionIdentifying and handling backpressureBest practices for your debugging environmentMonitoring and observabilityMonitoring concepts in Lambda-based applicationsLogging and metrics with Amazon CloudWatchHow CloudWatch structures logsImportant metrics for CloudWatchCustom metricsUsing AWS Resource Groups to organize your workloadSearching across logs with CloudWatch Logs InsightsParsing logs and structured loggingQuerying AWS-generated eventsLog visualization and dashboardsUseful Insights queriesTracing requests with AWS X-RayTroubleshooting walkthrough: isolating and resolving issuesA general approach to debugging Lambda performance issues and errorsMonitoring Lambda code storageBest practices for managing code storagePerformance optimizationLambda execution environmentsMemory and computing powerProfiling functions with AWS Lambda Power TuningOptimizing static initializationComparing the effect of global scopeStatic initialization and Provisioned ConcurrencyArchitecture and Best PracticesComparing performance of interactive and asynchronous workloadsWhen not to use a Lambda functionCost optimizationDocument historyAWS...DocumentationAWS LambdaDeveloper GuideAWSDocumentationAWS LambdaDeveloper GuideCreate your first Lambda function PDF RSSFocus modeOn this pagePrerequisitesCreate the functionInvoke the functionClean upNext stepsRelated resourcesAWS Lambda API ReferenceAWS CLI commands for AWS LambdaSDKs & Tools Did this page help you?YesNoProvide feedbackCreate your first Lambda function - AWS LambdaAWSDocumentationAWS LambdaDeveloper GuidePrerequisitesCreate the functionInvoke the functionClean upNext stepsTo get started with Lambda, use the Lambda console to create a function. In a few minutes, you can create and deploy a     function and test it in the console.As you carry out the tutorial, you'll learn some fundamental Lambda concepts, like how to pass arguments to      your function using the Lambda event object. You'll also learn how to return log outputs from your function, and how to      view your function's invocation logs in Amazon CloudWatch Logs.To keep things simple, you create your function using either the Python or Node.js runtime. With these interpreted languages, you can edit      function code directly in the console's built-in code editor. With compiled languages like Java and C#, you must to create a deployment package on    your local build machine and upload it to Lambda. To learn about deploying functions to Lambda using other runtimes, see the links in the      Additional resources and next steps section.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide. Prerequisites If you do not have an AWS account, complete the following steps to create one.To sign up for an AWS accountOpen https://portal.aws.amazon.com/billing/signup. Follow the online instructions. Part of the sign-up procedure involves receiving a phone call and entering    a verification code on the phone keypad. When you sign up for an AWS account, an AWS account root user is created. The root user has access to all AWS services   and resources in the account. As a security best practice, assign administrative access to a user, and use only the root user to perform tasks that require root user access. AWS sends you a confirmation email after the sign-up process is complete. At any time, you can view your current account activity and manage your account by going to https://aws.amazon.com/ and choosing My   Account.Sign up for an AWS accountIf you do not have an AWS account, complete the following steps to create one.To sign up for an AWS accountOpen https://portal.aws.amazon.com/billing/signup. Follow the online instructions. Part of the sign-up procedure involves receiving a phone call and entering    a verification code on the phone keypad. When you sign up for an AWS account, an AWS account root user is created. The root user has access to all AWS services   and resources in the account. As a security best practice, assign administrative access to a user, and use only the root user to perform tasks that require root user access. AWS sends you a confirmation email after the sign-up process is complete. At any time, you can view your current account activity and manage your account by going to https://aws.amazon.com/ and choosing My   Account.After you sign up for an AWS account, secure your AWS account root user, enable AWS IAM Identity Center, and create an administrative user so that you  don't use the root user for everyday tasks.Secure your AWS account root user  Sign in to the AWS Management Console as the account owner by choosing Root user and entering your AWS account email address. On the next page, enter your password. For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.  Turn on multi-factor authentication (MFA) for your root user. For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM User Guide. Create a user with administrative access Enable IAM Identity Center. For instructions, see Enabling  AWS IAM Identity Center in the  AWS IAM Identity Center User Guide.  In IAM Identity Center, grant administrative access to a user. For a tutorial about using the IAM Identity Center directory as your identity source, see   Configure user access with the default IAM Identity Center directory in the  AWS IAM Identity Center User Guide. Sign in as the user with administrative access To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email address when you created the IAM Identity Center user. For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the AWS Sign-In User Guide. Assign access to additional users In IAM Identity Center, create a permission set that follows the best practice of applying least-privilege permissions. For instructions, see   Create a permission set in the AWS IAM Identity Center User Guide.  Assign users to a group, and then assign single sign-on access to the group. For instructions, see   Add groups in the AWS IAM Identity Center User Guide. Create a user with administrative accessAfter you sign up for an AWS account, secure your AWS account root user, enable AWS IAM Identity Center, and create an administrative user so that you  don't use the root user for everyday tasks.Secure your AWS account root user  Sign in to the AWS Management Console as the account owner by choosing Root user and entering your AWS account email address. On the next page, enter your password. For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.  Turn on multi-factor authentication (MFA) for your root user. For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM User Guide. Create a user with administrative access Enable IAM Identity Center. For instructions, see Enabling  AWS IAM Identity Center in the  AWS IAM Identity Center User Guide.  In IAM Identity Center, grant administrative access to a user. For a tutorial about using the IAM Identity Center directory as your identity source, see   Configure user access with the default IAM Identity Center directory in the  AWS IAM Identity Center User Guide. Sign in as the user with administrative access To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email address when you created the IAM Identity Center user. For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the AWS Sign-In User Guide. Assign access to additional users In IAM Identity Center, create a permission set that follows the best practice of applying least-privilege permissions. For instructions, see   Create a permission set in the AWS IAM Identity Center User Guide.  Assign users to a group, and then assign single sign-on access to the group. For instructions, see   Add groups in the AWS IAM Identity Center User Guide.  Create a Lambda function with the console In this example, your function takes a JSON object containing two integer values labeled \"length\" and \"width\".        The function multiplies these values to calculate an area and returns this as a JSON string. Your function also prints the calculated area, along with the name of its CloudWatch log group. Later in the tutorial, you\u2019ll learn to use CloudWatch Logs        to view records of your functions\u2019 invocation. To create a Hello world Lambda function with the consoleOpen the Functions page of the Lambda console. Choose Create function.  Select Author from scratch.  In the Basic information pane, for Function name, enter                myLambdaFunction.  For Runtime, choose either Node.js 22.x or Python 3.13.  Leave architecture set to x86_64, and then choose Create function.  In addition to a simple function that returns the message Hello from Lambda!, Lambda also creates an execution role for your function. An execution role is an AWS Identity and Access Management (IAM) role that grants a Lambda function        permission to access AWS services and resources. For your function, the role that Lambda creates grants basic permissions to write to CloudWatch Logs. Use the console's built-in code editor to replace the Hello world code that Lambda created with your own function code.  Node.js To modify the code in the console Choose the Code tab. In the console's built-in code editor, you should see the function code that Lambda                created. If you don't see the index.mjs tab in the code editor, select index.mjs in the                file explorer as shown on the following diagram.     Paste the following code into the index.mjs tab, replacing the code that Lambda created. export const handler = async (event, context) => {      const length = event.length;   const width = event.width;   let area = calculateArea(length, width);   console.log(`The area is ${area}`);            console.log('CloudWatch log group: ', context.logGroupName);      let data = {     \"area\": area,   };     return JSON.stringify(data);        function calculateArea(length, width) {     return length * width;   } };  In the DEPLOY section, choose Deploy to update your function's code:     Understanding your function code Before you move to the next step, let's take a moment to look at the function code and understand some key Lambda concepts.   The Lambda handler: Your Lambda function contains a Node.js function named handler. A Lambda function in Node.js can contain more                    than one Node.js function, but the handler function is always the entry point to your code. When your function is                    invoked, Lambda runs this method.  When you created your Hello world function using the console, Lambda automatically set the name of the handler method for your                    function to handler. Be sure not to edit the name of this Node.js function. If you do, Lambda won\u2019t be able to run your code                    when you invoke your function. To learn more about the Lambda handler in Node.js, see Define Lambda function handler in Node.js.  The Lambda event object: The function handler takes two arguments, event and context. An event in Lambda is a JSON formatted document that contains data for your function to process. If your function is invoked by another AWS service, the event object contains information about the event that caused the invocation. For example, if your function is invoked when an object is uploaded to an Amazon Simple Storage Service (Amazon S3) bucket, the event contains the name of the bucket and the object key. In this example, you\u2019ll create an event in the console by entering a JSON formatted document with two key-value pairs.  The Lambda context object: The second argument that your function takes is context. Lambda passes the context object to your                    function automatically. The context object contains information about the function invocation and execution environment. You can use the context object to output information about your function's invocation for monitoring purposes. In this example,                    your function uses the logGroupName parameter to output the name of its CloudWatch log group. To learn more about the Lambda context object in Node.js, see Using the Lambda context object to retrieve Node.js function information.  Logging in Lambda: With Node.js, you can use console methods like console.log and console.error to send information to your                    function's log. The example code uses console.log statements to output the calculated area and the name of the                    function's CloudWatch Logs group. You can also use any logging library that writes to stdout or stderr.  To learn more, see Log and monitor Node.js Lambda functions. To learn about logging in other runtimes, see the 'Building with' pages                      for the runtimes you're interested in.   Python To modify the code in the console Choose the Code tab. In the console's built-in code editor, you should see the function code that Lambda                  created. If you don't see the lambda_function.py tab in the code editor, select lambda_function.py                  in the file explorer as shown on the following diagram.     Paste the following code into the lambda_function.py tab, replacing the code that Lambda created. import json import logging  logger = logging.getLogger() logger.setLevel(logging.INFO)  def lambda_handler(event, context):          # Get the length and width parameters from the event object. The      # runtime converts the event object to a Python dictionary     length = event['length']     width = event['width']          area = calculate_area(length, width)     print(f\"The area is {area}\")              logger.info(f\"CloudWatch logs group: {context.log_group_name}\")          # return the calculated area as a JSON string     data = {\"area\": area}     return json.dumps(data)      def calculate_area(length, width):     return length*width  In the DEPLOY section, choose Deploy to update your function's code:     Understanding your function code Before you move to the next step, let's take a moment to look at the function code and understand some key Lambda concepts.   The Lambda handler: Your Lambda function contains a Python function named lambda_handler. A Lambda function in Python can contain more                  than one Python function, but the handler function is always the entry point to your code. When your function is                  invoked, Lambda runs this method.  When you created your Hello world function using the console, Lambda automatically set the name of the handler method for your                  function to lambda_handler. Be sure not to edit the name of this Python function. If you do, Lambda won\u2019t be able to run your code                  when you invoke your function. To learn more about the Lambda handler in Python, see Define Lambda function handler in Python.  The Lambda event object: The function lambda_handler takes two arguments, event and context. An event                  in Lambda is a JSON formatted document that contains data for your function to process. If your function is invoked by another AWS service, the event object contains information about the event that caused the                  invocation. For example, if your function is invoked when an object is uploaded to an Amazon Simple Storage Service (Amazon S3) bucket, the event contains the name of the bucket and the object key. In this example, you\u2019ll create an event in the console by entering a JSON formatted document with two key-value pairs.  The Lambda context object: The second argument that your function takes is context. Lambda passes the context object to your                  function automatically. The context object contains information about the function invocation and execution environment. You can use the context object to output information about your function's invocation for monitoring purposes. In this example,                  your function uses the log_group_name parameter to output the name of its CloudWatch log group. To learn more about the Lambda context object in Python, see Using the Lambda context object to retrieve Python function information.  Logging in Lambda: With Python, you can use either a print statement or a Python logging library to send information to your function's                  log. To illustrate the difference in what's captured, the example code uses both methods. In a production application, we recommend                  that you use a logging library. To learn more, see Log and monitor Python Lambda functions. To learn about logging in other runtimes, see the                'Building with' pages for the runtimes you're interested in.   anchoranchorNode.jsPython To modify the code in the console Choose the Code tab. In the console's built-in code editor, you should see the function code that Lambda                created. If you don't see the index.mjs tab in the code editor, select index.mjs in the                file explorer as shown on the following diagram.     Paste the following code into the index.mjs tab, replacing the code that Lambda created. export const handler = async (event, context) => {      const length = event.length;   const width = event.width;   let area = calculateArea(length, width);   console.log(`The area is ${area}`);            console.log('CloudWatch log group: ', context.logGroupName);      let data = {     \"area\": area,   };     return JSON.stringify(data);        function calculateArea(length, width) {     return length * width;   } };  In the DEPLOY section, choose Deploy to update your function's code:     Understanding your function code Before you move to the next step, let's take a moment to look at the function code and understand some key Lambda concepts.   The Lambda handler: Your Lambda function contains a Node.js function named handler. A Lambda function in Node.js can contain more                    than one Node.js function, but the handler function is always the entry point to your code. When your function is                    invoked, Lambda runs this method.  When you created your Hello world function using the console, Lambda automatically set the name of the handler method for your                    function to handler. Be sure not to edit the name of this Node.js function. If you do, Lambda won\u2019t be able to run your code                    when you invoke your function. To learn more about the Lambda handler in Node.js, see Define Lambda function handler in Node.js.  The Lambda event object: The function handler takes two arguments, event and context. An event in Lambda is a JSON formatted document that contains data for your function to process. If your function is invoked by another AWS service, the event object contains information about the event that caused the invocation. For example, if your function is invoked when an object is uploaded to an Amazon Simple Storage Service (Amazon S3) bucket, the event contains the name of the bucket and the object key. In this example, you\u2019ll create an event in the console by entering a JSON formatted document with two key-value pairs.  The Lambda context object: The second argument that your function takes is context. Lambda passes the context object to your                    function automatically. The context object contains information about the function invocation and execution environment. You can use the context object to output information about your function's invocation for monitoring purposes. In this example,                    your function uses the logGroupName parameter to output the name of its CloudWatch log group. To learn more about the Lambda context object in Node.js, see Using the Lambda context object to retrieve Node.js function information.  Logging in Lambda: With Node.js, you can use console methods like console.log and console.error to send information to your                    function's log. The example code uses console.log statements to output the calculated area and the name of the                    function's CloudWatch Logs group. You can also use any logging library that writes to stdout or stderr.  To learn more, see Log and monitor Node.js Lambda functions. To learn about logging in other runtimes, see the 'Building with' pages                      for the runtimes you're interested in.   Invoke the Lambda function using the console code editor To invoke your function using the Lambda console code editor, create a test event to send to your function. The event is a JSON formatted            document containing two key-value pairs with the keys \"length\" and \"width\". To create the test event In the TEST EVENTS section of the console code editor, choose Create test event.     For Event Name, enter myTestEvent.  In the Event JSON section, replace the default JSON with the following: {   \"length\": 6,   \"width\": 7 }  Choose Save.  To test your function and view invocation records In the TEST EVENTS section of the console code editor, choose the run icon next to your test event:    When your function finishes running, the response and function logs are displayed in the OUTPUT tab. You should see results similar to the following:  Node.js Status: Succeeded Test Event Name: myTestEvent  Response \"{\\\"area\\\":42}\"  Function Logs START RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a Version: $LATEST 2024-08-31T23:39:45.313Z\t5c012b0a-18f7-4805-b2f6-40912935034a\tINFO\tThe area is 42 2024-08-31T23:39:45.331Z\t5c012b0a-18f7-4805-b2f6-40912935034a\tINFO\tCloudWatch log group:  /aws/lambda/myLambdaFunction END RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a REPORT RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a\tDuration: 20.67 ms\tBilled Duration: 21 ms\tMemory Size: 128 MB\tMax Memory Used: 66 MB\tInit Duration: 163.87 ms  Request ID 5c012b0a-18f7-4805-b2f6-40912935034a  Python Status: Succeeded Test Event Name: myTestEvent  Response \"{\\\"area\\\": 42}\"  Function Logs START RequestId: 2d0b1579-46fb-4bf7-a6e1-8e08840eae5b Version: $LATEST The area is 42 [INFO]\t2024-08-31T23:43:26.428Z\t2d0b1579-46fb-4bf7-a6e1-8e08840eae5b\tCloudWatch logs group: /aws/lambda/myLambdaFunction END RequestId: 2d0b1579-46fb-4bf7-a6e1-8e08840eae5b REPORT RequestId: 2d0b1579-46fb-4bf7-a6e1-8e08840eae5b\tDuration: 1.42 ms\tBilled Duration: 2 ms\tMemory Size: 128 MB\tMax Memory Used: 39 MB\tInit Duration: 123.74 ms  Request ID 2d0b1579-46fb-4bf7-a6e1-8e08840eae5b  anchoranchorNode.jsPython Status: Succeeded Test Event Name: myTestEvent  Response \"{\\\"area\\\":42}\"  Function Logs START RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a Version: $LATEST 2024-08-31T23:39:45.313Z\t5c012b0a-18f7-4805-b2f6-40912935034a\tINFO\tThe area is 42 2024-08-31T23:39:45.331Z\t5c012b0a-18f7-4805-b2f6-40912935034a\tINFO\tCloudWatch log group:  /aws/lambda/myLambdaFunction END RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a REPORT RequestId: 5c012b0a-18f7-4805-b2f6-40912935034a\tDuration: 20.67 ms\tBilled Duration: 21 ms\tMemory Size: 128 MB\tMax Memory Used: 66 MB\tInit Duration: 163.87 ms  Request ID 5c012b0a-18f7-4805-b2f6-40912935034a  When you invoke your function outside of the Lambda console, you must use CloudWatch Logs to view your function's execution results. To view your function's invocation records in CloudWatch Logs Open the Log groups page of the CloudWatch console.  Choose the log group for your function (/aws/lambda/myLambdaFunction). This is the log group name that your                  function printed to the console.  Scroll down and choose the Log stream for the function invocations you want to look at.    You should see output similar to the following:  Node.js INIT_START Runtime Version: nodejs:22.v13    Runtime Version ARN: arn:aws:lambda:us-west-2::runtime:e3aaabf6b92ef8755eaae2f4bfdcb7eb8c4536a5e044900570a42bdba7b869d9 START RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20 Version: $LATEST 2024-08-23T22:04:15.809Z    5c012b0a-18f7-4805-b2f6-40912935034a  INFO\tThe area is 42 2024-08-23T22:04:15.810Z    aba6c0fc-cf99-49d7-a77d-26d805dacd20  INFO  CloudWatch log group:  /aws/lambda/myLambdaFunction END RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20 REPORT RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20    Duration: 17.77 ms    Billed Duration: 18 ms    Memory Size: 128 MB    Max Memory Used: 67 MB    Init Duration: 178.85 ms      Python INIT_START Runtime Version: python:3.13.v16    Runtime Version ARN: arn:aws:lambda:us-west-2::runtime:ca202755c87b9ec2b58856efb7374b4f7b655a0ea3deb1d5acc9aee9e297b072 START RequestId: 9d4096ee-acb3-4c25-be10-8a210f0a9d8e Version: $LATEST The area is 42 [INFO]\t2024-09-01T00:05:22.464Z\t9315ab6b-354a-486e-884a-2fb2972b7d84\tCloudWatch logs group: /aws/lambda/myLambdaFunction END RequestId: 9d4096ee-acb3-4c25-be10-8a210f0a9d8e  REPORT RequestId: 9d4096ee-acb3-4c25-be10-8a210f0a9d8e    Duration: 1.15 ms    Billed Duration: 2 ms    Memory Size: 128 MB    Max Memory Used: 40 MB      anchoranchorNode.jsPython INIT_START Runtime Version: nodejs:22.v13    Runtime Version ARN: arn:aws:lambda:us-west-2::runtime:e3aaabf6b92ef8755eaae2f4bfdcb7eb8c4536a5e044900570a42bdba7b869d9 START RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20 Version: $LATEST 2024-08-23T22:04:15.809Z    5c012b0a-18f7-4805-b2f6-40912935034a  INFO\tThe area is 42 2024-08-23T22:04:15.810Z    aba6c0fc-cf99-49d7-a77d-26d805dacd20  INFO  CloudWatch log group:  /aws/lambda/myLambdaFunction END RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20 REPORT RequestId: aba6c0fc-cf99-49d7-a77d-26d805dacd20    Duration: 17.77 ms    Billed Duration: 18 ms    Memory Size: 128 MB    Max Memory Used: 67 MB    Init Duration: 178.85 ms       Clean up When you're finished working with the example function, delete it. You can also delete the log group that stores             the function's logs, and the execution role that the console created. To delete the Lambda function Open the Functions page of the Lambda console.  Select the function that you created.  Choose Actions, Delete.  Type delete in the text input field and choose Delete.  To delete the log group Open the Log groups page of the CloudWatch                 console.  Select the function's log group (/aws/lambda/myLambdaFunction).  Choose Actions, Delete log group(s).  In the Delete log group(s) dialog box, choose Delete.  To delete the execution role Open the Roles page of the AWS Identity and Access Management (IAM)                 console.  Select the function's execution role (for example, myLambdaFunction-role-31exxmpl).  Choose Delete.  In the Delete role dialog box, enter the role name, and then choose Delete.  Additional resources and next steps Now that you\u2019ve created and tested a simple Lambda function using the console, take these next steps:   Learn to add dependencies to your function and deploy it using a .zip deployment package. Choose your preferred language from the following links.  Node.js Deploy Node.js Lambda functions with .zip file archives  Typescript Deploy transpiled TypeScript code in Lambda with .zip file archives  Python Working with .zip file archives for Python Lambda functions  Ruby Deploy Ruby Lambda functions with .zip file archives  Java Deploy Java Lambda functions with .zip or JAR file archives  Go Deploy Go Lambda functions with .zip file archives  C# Build and deploy C# Lambda functions with .zip file archives  anchoranchoranchoranchoranchoranchoranchorNode.jsTypescriptPythonRubyJavaGoC# Deploy Node.js Lambda functions with .zip file archives   To learn how to invoke a Lambda function using another AWS service, see Tutorial: Using an Amazon S3 trigger to invoke a Lambda function.  Choose one of the following tutorials for more complex examples of using Lambda with other AWS services.   Tutorial: Using Lambda with API Gateway: Create an Amazon API Gateway REST                          API that invokes a Lambda function.  Using a Lambda function to                          access an Amazon RDS database: Use a Lambda function to write data to an Amazon Relational Database Service (Amazon RDS) database through RDS Proxy.  Using an Amazon S3 trigger to create thumbnail images: Use a Lambda function to create a thumbnail every time an image file is uploaded to                          an Amazon S3 bucket.    Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsWhat is AWS Lambda?Example appsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.Next topic:Example appsPrevious topic:What is AWS Lambda?Need help?Try AWS re:Post Connect with an AWS IQ expert PrivacySite termsCookie preferences       \u00a9 2024, Amazon Web Services, Inc. or its affiliates. All rights reserved."
        ]
    },
    {
        "title": "Example apps",
        "source": "aws_lambda",
        "url": "https://docs.aws.amazon.com/lambda/latest/dg/example-apps.html",
        "sections": [
            "Contact UsEnglishCreate an AWS AccountFeedback Preferences AWS LambdaDeveloper GuideWhat is AWS Lambda?Create your first functionExample appsFile-processing appScheduled-maintenance appKey Lambda conceptsInfrastructure as code (IaC)Using the AWS CDKProgramming modelLambda runtimesRuntime version updatesConfiguring runtime managementRuntime version roll-backIdentifying Lambda runtime version changesShared responsibility modelPermissionsGet data about functions by runtimeRuntime modificationsRuntime APIOS-only runtimesBuilding a custom runtimeCustom runtime tutorialExecution environmentConfiguring functions.zip file archivesEncryptionContainer imagesMemoryEphemeral storageInstruction sets (ARM/x86)TimeoutEnvironment variablesSecuring environment variablesRetrieving environment variablesAttaching functions to a VPCAttaching functions to resources in another accountInternet access for VPC functionsInbound networkingFile systemAliasesUsing aliasesRouting configurationsVersionsTagsResponse streamingWriting functionsInvoking functionsTutorial: Creating a response streaming function with a function URLInvoking functionsInvoke a function synchronouslyAsynchronous invocationError handlingConfigurationRetaining recordsEvent source mappingsEvent source mapping tagsEvent filteringTesting in consoleFunction statesRetriesRecursive loop detectionFunction URLsAccess controlInvoking function URLsMonitoring function URLsSelect an HTTP invoke method for LambdaTutorial: Creating a function with a function URLFunction scalingConfiguring reserved concurrencyConfiguring provisioned concurrencyScaling behaviorMonitoring concurrencyBuilding with Node.jsHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with TypeScriptHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with PythonHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTestingTracingBuilding with RubyHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with JavaHandlerDeploy .zip file archivesDeploy container imagesLayersCustom serializationCustom startup behaviorContextLoggingTracingSample appsBuilding with GoHandlerContextDeploy .zip file archivesDeploy container imagesLayersLoggingTracingBuilding with C#HandlerDeployment packageNET Lambda Global CLIAWS SAMAWS CDKASP.NETDeploy container imagesNative AOT compilationContextLoggingTracingTestingBuilding with PowerShellDevelopment EnvironmentDeployment packageHandlerContextLoggingBuilding with RustHandlerContextHTTP eventsDeploy .zip file archivesLoggingBest practicesTesting serverless functionsLambda SnapStartActivating SnapStartHandling uniquenessRuntime hooksJavaPython.NETMonitoringSecurity modelBest practicesTroubleshootingIntegrating other servicesApache KafkaConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTroubleshootingAPI GatewayTutorialErrorsSelect an HTTP invoke method for LambdaInfrastructure ComposerCloudFormationAmazon DocumentDBTutorialDynamoDBCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialEC2Elastic Load Balancing (Application Load Balancer)Invoke using an EventBridge SchedulerIoTKinesis Data StreamsCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialMQConfigure event sourceParametersEvent filteringTroubleshootMSKConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTutorialRDSS3Tutorial: Use an S3 triggerTutorial: Use an Amazon S3 trigger to create thumbnailsSQSCreate mappingScaling behaviorError handlingParametersEvent filteringTutorialSQS cross-account tutorialS3 BatchSNSTutorialLambda permissionsExecution role (permissions for functions to access other resources)Update execution roleAWS managed policiesSource function ARNAccess permissions (permissions for other entities to access your functions)Identity-based policiesFunction accessLayer accessResource-based policiesFunction access for AWS servicesFunction access for AWS OrganizationsFunction access for other accountsLayer access for other accountsAttribute-based access controlSecure your functions by tagResources and ConditionsSecurity, governance, and complianceData protectionEncryption at restIdentity and Access ManagementHow AWS Lambda works with IAMIdentity-based policy examplesAWS managed policiesTroubleshootingGovernanceProactive controls with GuardProactive controls with AWS ConfigDetective controls with AWS ConfigCode signingCode scanningObservabilityCompliance validationResilienceInfrastructure securityCode signingCreate configurationUpdate configurationPermissionsCode signing configuration tagsMonitoring functionsFunction metricsView function metricsMetric typesFunction logsConfigure function logsView function logsCloudTrail logsAWS X-RayFunction insightsApplication SignalsLambda layersPackaging layersCreating and deleting layersAdding layersLayers with AWS CloudFormationLayers with AWS SAMLambda extensionsConfiguring extensionsExtensions partnersExtensions APITelemetry APIAPI referenceEvent schema referenceConverting events to OTel SpansLogs APITroubleshootingDeploymentInvocationExecutionNetworkingLambda applicationsMonitoring applicationsRolling deploymentsKubernetesSample applicationsWorking with AWS SDKsCode examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examplesConnecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS triggerLambda quotasOperator GuideIntroductionEvent-driven architecturesHow Lambda fits into the event-driven paradigmThe benefits of event-driven architecturesTrade-offs of event-driven architecturesDesign principlesUse services instead of custom codeUnderstanding the level of abstractionImplementing statelessness in functionsLambda function designBuilding for on-demand data instead of batchesOrchestrationDeveloping for retries and failuresAnti-patterns in Lambda-based applicationsThe Lambda monolithLambda as orchestratorRecursive patterns that cause run-away Lambda functionsLambda functions calling Lambda functionsSynchronous waiting within a single Lambda functionFrequently asked questionsApplication designUnderstanding quotasArchitecting with Service QuotasUsing multiple AWS accounts for managing quotasScaling and concurrency in LambdaChoosing and managing runtimes in Lambda functionsRuntimes and performanceMultiple runtimes in single applicationsManaging AWS SDKs in Lambda functionsNetworking and VPC configurationsComparing Lambda invocation modesUnderstanding SQS retriesControlling traffic flow for server-based resourcesFrequently asked questionsSecurityUnderstanding the Lambda execution environmentApplying the principles of least privilegeDeveloping least privilege IAM rolesAccess to CloudWatch LogsAvoiding granting wildcard permissions in IAM policiesSpecialized Lambda functions compared with all-purpose functionsSecuring workloads with public endpointsEncrypting data in Lambda-based applicationsGovernance controls with AWS CloudTrailFrequently asked questionsDebuggingStandardizing a debugging approachGeneral types of errorTroubleshooting payloadsTroubleshooting integration errorsTroubleshooting Lambda configurationsTroubleshooting queue processing by Lambda functionsIdentifying and managing throttlingErrors in the processing functionIdentifying and handling backpressureBest practices for your debugging environmentMonitoring and observabilityMonitoring concepts in Lambda-based applicationsLogging and metrics with Amazon CloudWatchHow CloudWatch structures logsImportant metrics for CloudWatchCustom metricsUsing AWS Resource Groups to organize your workloadSearching across logs with CloudWatch Logs InsightsParsing logs and structured loggingQuerying AWS-generated eventsLog visualization and dashboardsUseful Insights queriesTracing requests with AWS X-RayTroubleshooting walkthrough: isolating and resolving issuesA general approach to debugging Lambda performance issues and errorsMonitoring Lambda code storageBest practices for managing code storagePerformance optimizationLambda execution environmentsMemory and computing powerProfiling functions with AWS Lambda Power TuningOptimizing static initializationComparing the effect of global scopeStatic initialization and Provisioned ConcurrencyArchitecture and Best PracticesComparing performance of interactive and asynchronous workloadsWhen not to use a Lambda functionCost optimizationDocument historyAWS...DocumentationAWS LambdaDeveloper GuideAWSDocumentationAWS LambdaDeveloper GuideExample serverless apps PDF RSSFocus modeOn this pageExample appsRelated resourcesAWS Lambda API ReferenceAWS CLI commands for AWS LambdaSDKs & Tools Did this page help you?YesNoProvide feedbackExample serverless apps - AWS LambdaAWSDocumentationAWS LambdaDeveloper GuideExample appsThe following examples provide function code and   infrastructure as code (IaC) templates to quickly create and deploy serverless apps that implement some common Lambda uses cases. The   examples also include code examples and instructions to test the apps after you deploy them.For each of the example apps, we provide instructions to either create and configure resources manually using the AWS Management Console, or to    use the AWS Serverless Application Model to deploy the resources using IaC. Follow the console intructions to learn more about configuring the individual AWS    resources for each app, or use to AWS SAM to quickly deploy resources as you would in a production environment.You can use the provided examples as a basis for your own serverless applications by modifying the provided function code and templates    for your own use case.We're continuing to create new examples, so check back again to find more severless apps for common Lambda use cases. Example apps   Example serverless file-processing app Create a serverless app to automatically perform a file-processing task when an object is uploaded to an Amazon S3 bucket. In this          example, when a PDF file is uploaded, the app encrypts the file and saves it to another S3 bucket.  Example scheduled cron task app Create an app to perform a scheduled task using a cron schedule. In this example, the app performs maintenance on a          Amazon DynamoDB table by deleting entries more than 12 months old.   Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsCreate your first functionFile-processing appDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.Next topic:File-processing appPrevious topic:Create your first functionNeed help?Try AWS re:Post Connect with an AWS IQ expert PrivacySite termsCookie preferences       \u00a9 2024, Amazon Web Services, Inc. or its affiliates. All rights reserved."
        ]
    },
    {
        "title": "Building with TypeScript",
        "source": "aws_lambda",
        "url": "https://docs.aws.amazon.com/lambda/latest/dg/lambda-typescript.html",
        "sections": [
            "Contact UsEnglishCreate an AWS AccountFeedback Preferences AWS LambdaDeveloper GuideWhat is AWS Lambda?Create your first functionExample appsFile-processing appScheduled-maintenance appKey Lambda conceptsInfrastructure as code (IaC)Using the AWS CDKProgramming modelLambda runtimesRuntime version updatesConfiguring runtime managementRuntime version roll-backIdentifying Lambda runtime version changesShared responsibility modelPermissionsGet data about functions by runtimeRuntime modificationsRuntime APIOS-only runtimesBuilding a custom runtimeCustom runtime tutorialExecution environmentConfiguring functions.zip file archivesEncryptionContainer imagesMemoryEphemeral storageInstruction sets (ARM/x86)TimeoutEnvironment variablesSecuring environment variablesRetrieving environment variablesAttaching functions to a VPCAttaching functions to resources in another accountInternet access for VPC functionsInbound networkingFile systemAliasesUsing aliasesRouting configurationsVersionsTagsResponse streamingWriting functionsInvoking functionsTutorial: Creating a response streaming function with a function URLInvoking functionsInvoke a function synchronouslyAsynchronous invocationError handlingConfigurationRetaining recordsEvent source mappingsEvent source mapping tagsEvent filteringTesting in consoleFunction statesRetriesRecursive loop detectionFunction URLsAccess controlInvoking function URLsMonitoring function URLsSelect an HTTP invoke method for LambdaTutorial: Creating a function with a function URLFunction scalingConfiguring reserved concurrencyConfiguring provisioned concurrencyScaling behaviorMonitoring concurrencyBuilding with Node.jsHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with TypeScriptHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with PythonHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTestingTracingBuilding with RubyHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with JavaHandlerDeploy .zip file archivesDeploy container imagesLayersCustom serializationCustom startup behaviorContextLoggingTracingSample appsBuilding with GoHandlerContextDeploy .zip file archivesDeploy container imagesLayersLoggingTracingBuilding with C#HandlerDeployment packageNET Lambda Global CLIAWS SAMAWS CDKASP.NETDeploy container imagesNative AOT compilationContextLoggingTracingTestingBuilding with PowerShellDevelopment EnvironmentDeployment packageHandlerContextLoggingBuilding with RustHandlerContextHTTP eventsDeploy .zip file archivesLoggingBest practicesTesting serverless functionsLambda SnapStartActivating SnapStartHandling uniquenessRuntime hooksJavaPython.NETMonitoringSecurity modelBest practicesTroubleshootingIntegrating other servicesApache KafkaConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTroubleshootingAPI GatewayTutorialErrorsSelect an HTTP invoke method for LambdaInfrastructure ComposerCloudFormationAmazon DocumentDBTutorialDynamoDBCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialEC2Elastic Load Balancing (Application Load Balancer)Invoke using an EventBridge SchedulerIoTKinesis Data StreamsCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialMQConfigure event sourceParametersEvent filteringTroubleshootMSKConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTutorialRDSS3Tutorial: Use an S3 triggerTutorial: Use an Amazon S3 trigger to create thumbnailsSQSCreate mappingScaling behaviorError handlingParametersEvent filteringTutorialSQS cross-account tutorialS3 BatchSNSTutorialLambda permissionsExecution role (permissions for functions to access other resources)Update execution roleAWS managed policiesSource function ARNAccess permissions (permissions for other entities to access your functions)Identity-based policiesFunction accessLayer accessResource-based policiesFunction access for AWS servicesFunction access for AWS OrganizationsFunction access for other accountsLayer access for other accountsAttribute-based access controlSecure your functions by tagResources and ConditionsSecurity, governance, and complianceData protectionEncryption at restIdentity and Access ManagementHow AWS Lambda works with IAMIdentity-based policy examplesAWS managed policiesTroubleshootingGovernanceProactive controls with GuardProactive controls with AWS ConfigDetective controls with AWS ConfigCode signingCode scanningObservabilityCompliance validationResilienceInfrastructure securityCode signingCreate configurationUpdate configurationPermissionsCode signing configuration tagsMonitoring functionsFunction metricsView function metricsMetric typesFunction logsConfigure function logsView function logsCloudTrail logsAWS X-RayFunction insightsApplication SignalsLambda layersPackaging layersCreating and deleting layersAdding layersLayers with AWS CloudFormationLayers with AWS SAMLambda extensionsConfiguring extensionsExtensions partnersExtensions APITelemetry APIAPI referenceEvent schema referenceConverting events to OTel SpansLogs APITroubleshootingDeploymentInvocationExecutionNetworkingLambda applicationsMonitoring applicationsRolling deploymentsKubernetesSample applicationsWorking with AWS SDKsCode examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examplesConnecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS triggerLambda quotasOperator GuideIntroductionEvent-driven architecturesHow Lambda fits into the event-driven paradigmThe benefits of event-driven architecturesTrade-offs of event-driven architecturesDesign principlesUse services instead of custom codeUnderstanding the level of abstractionImplementing statelessness in functionsLambda function designBuilding for on-demand data instead of batchesOrchestrationDeveloping for retries and failuresAnti-patterns in Lambda-based applicationsThe Lambda monolithLambda as orchestratorRecursive patterns that cause run-away Lambda functionsLambda functions calling Lambda functionsSynchronous waiting within a single Lambda functionFrequently asked questionsApplication designUnderstanding quotasArchitecting with Service QuotasUsing multiple AWS accounts for managing quotasScaling and concurrency in LambdaChoosing and managing runtimes in Lambda functionsRuntimes and performanceMultiple runtimes in single applicationsManaging AWS SDKs in Lambda functionsNetworking and VPC configurationsComparing Lambda invocation modesUnderstanding SQS retriesControlling traffic flow for server-based resourcesFrequently asked questionsSecurityUnderstanding the Lambda execution environmentApplying the principles of least privilegeDeveloping least privilege IAM rolesAccess to CloudWatch LogsAvoiding granting wildcard permissions in IAM policiesSpecialized Lambda functions compared with all-purpose functionsSecuring workloads with public endpointsEncrypting data in Lambda-based applicationsGovernance controls with AWS CloudTrailFrequently asked questionsDebuggingStandardizing a debugging approachGeneral types of errorTroubleshooting payloadsTroubleshooting integration errorsTroubleshooting Lambda configurationsTroubleshooting queue processing by Lambda functionsIdentifying and managing throttlingErrors in the processing functionIdentifying and handling backpressureBest practices for your debugging environmentMonitoring and observabilityMonitoring concepts in Lambda-based applicationsLogging and metrics with Amazon CloudWatchHow CloudWatch structures logsImportant metrics for CloudWatchCustom metricsUsing AWS Resource Groups to organize your workloadSearching across logs with CloudWatch Logs InsightsParsing logs and structured loggingQuerying AWS-generated eventsLog visualization and dashboardsUseful Insights queriesTracing requests with AWS X-RayTroubleshooting walkthrough: isolating and resolving issuesA general approach to debugging Lambda performance issues and errorsMonitoring Lambda code storageBest practices for managing code storagePerformance optimizationLambda execution environmentsMemory and computing powerProfiling functions with AWS Lambda Power TuningOptimizing static initializationComparing the effect of global scopeStatic initialization and Provisioned ConcurrencyArchitecture and Best PracticesComparing performance of interactive and asynchronous workloadsWhen not to use a Lambda functionCost optimizationDocument historyAWS...DocumentationAWS LambdaDeveloper GuideAWSDocumentationAWS LambdaDeveloper GuideBuilding Lambda functions with TypeScript PDF RSSFocus modeOn this pageDevelopment environmentRelated resourcesAWS Lambda API ReferenceAWS CLI commands for AWS LambdaSDKs & Tools Did this page help you?YesNoProvide feedbackBuilding Lambda functions with TypeScript - AWS LambdaAWSDocumentationAWS LambdaDeveloper GuideDevelopment environmentYou can use the Node.js runtime to run TypeScript code in AWS Lambda. Because Node.js doesn't run TypeScript code natively, you must first      transpile your TypeScript code into JavaScript. Then, use the JavaScript files to deploy your function code to Lambda. Your code runs in an      environment that includes the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more      about the SDK versions included with the Node.js runtimes, see Runtime-included SDK versions.Lambda supports the following Node.js runtimes.  Name Identifier Operating system Deprecation date Block function create Block function update     Node.js 22   nodejs22.x   Amazon Linux 2023                Not scheduled                             Not scheduled                             Not scheduled                  Node.js 20   nodejs20.x   Amazon Linux 2023                Not scheduled                             Not scheduled                             Not scheduled                  Node.js 18   nodejs18.x   Amazon Linux 2               Jul 31, 2025                            Sep 1, 2025                            Oct 1, 2025                TopicsSetting up a TypeScript development environmentDefine Lambda function handler in TypeScriptDeploy transpiled TypeScript code in Lambda with .zip file archivesDeploy transpiled TypeScript code in Lambda with container imagesWorking with layers for TypeScript Lambda functionsUsing the Lambda context object to retrieve TypeScript function informationLog and monitor TypeScript Lambda functionsTracing TypeScript code in AWS Lambda Setting up a TypeScript development environment Use a local integrated development environment (IDE), text editor, or AWS Cloud9 to write your TypeScript function code. You can\u2019t create TypeScript code on the Lambda console. To transpile your TypeScript code, set up a compiler such as esbuild or Microsoft's TypeScript compiler (tsc) , which is bundled with the TypeScript distribution. You can use the AWS Serverless Application Model (AWS SAM) or the AWS Cloud Development Kit (AWS CDK) to simplify building and deploying TypeScript code. Both tools use esbuild to transpile TypeScript code into JavaScript. When using esbuild, consider the following:   There are several TypeScript caveats.  You must configure your TypeScript transpilation settings to match the Node.js runtime that you plan to use. For more information, see Target in the esbuild documentation. For an example of a tsconfig.json file that demonstrates how to target a specific Node.js version supported by Lambda, refer to the TypeScript GitHub repository.  esbuild doesn\u2019t perform type checks. To check types, use the tsc compiler. Run tsc -noEmit or add a \"noEmit\" parameter to your tsconfig.json file, as shown in the following example. This configures tsc to not emit JavaScript files. After checking types, use esbuild to convert the TypeScript files into JavaScript.  Example  tsconfig.json {   \"compilerOptions\": {     \"target\": \"es2020\",     \"strict\": true,     \"preserveConstEnums\": true,     \"noEmit\": true,     \"sourceMap\": false,     \"module\":\"commonjs\",     \"moduleResolution\":\"node\",     \"esModuleInterop\": true,      \"skipLibCheck\": true,     \"forceConsistentCasingInFileNames\": true,      \"isolatedModules\": true,    },   \"exclude\": [\"node_modules\", \"**/*.test.ts\"] }  Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsTracingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.Next topic:HandlerPrevious topic:TracingNeed help?Try AWS re:Post Connect with an AWS IQ expert PrivacySite termsCookie preferences       \u00a9 2024, Amazon Web Services, Inc. or its affiliates. All rights reserved."
        ]
    },
    {
        "title": "Integrating other services",
        "source": "aws_lambda",
        "url": "https://docs.aws.amazon.com/lambda/latest/dg/lambda-services.html",
        "sections": [
            "Contact UsEnglishCreate an AWS AccountFeedback Preferences AWS LambdaDeveloper GuideWhat is AWS Lambda?Create your first functionExample appsFile-processing appScheduled-maintenance appKey Lambda conceptsInfrastructure as code (IaC)Using the AWS CDKProgramming modelLambda runtimesRuntime version updatesConfiguring runtime managementRuntime version roll-backIdentifying Lambda runtime version changesShared responsibility modelPermissionsGet data about functions by runtimeRuntime modificationsRuntime APIOS-only runtimesBuilding a custom runtimeCustom runtime tutorialExecution environmentConfiguring functions.zip file archivesEncryptionContainer imagesMemoryEphemeral storageInstruction sets (ARM/x86)TimeoutEnvironment variablesSecuring environment variablesRetrieving environment variablesAttaching functions to a VPCAttaching functions to resources in another accountInternet access for VPC functionsInbound networkingFile systemAliasesUsing aliasesRouting configurationsVersionsTagsResponse streamingWriting functionsInvoking functionsTutorial: Creating a response streaming function with a function URLInvoking functionsInvoke a function synchronouslyAsynchronous invocationError handlingConfigurationRetaining recordsEvent source mappingsEvent source mapping tagsEvent filteringTesting in consoleFunction statesRetriesRecursive loop detectionFunction URLsAccess controlInvoking function URLsMonitoring function URLsSelect an HTTP invoke method for LambdaTutorial: Creating a function with a function URLFunction scalingConfiguring reserved concurrencyConfiguring provisioned concurrencyScaling behaviorMonitoring concurrencyBuilding with Node.jsHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with TypeScriptHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with PythonHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTestingTracingBuilding with RubyHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with JavaHandlerDeploy .zip file archivesDeploy container imagesLayersCustom serializationCustom startup behaviorContextLoggingTracingSample appsBuilding with GoHandlerContextDeploy .zip file archivesDeploy container imagesLayersLoggingTracingBuilding with C#HandlerDeployment packageNET Lambda Global CLIAWS SAMAWS CDKASP.NETDeploy container imagesNative AOT compilationContextLoggingTracingTestingBuilding with PowerShellDevelopment EnvironmentDeployment packageHandlerContextLoggingBuilding with RustHandlerContextHTTP eventsDeploy .zip file archivesLoggingBest practicesTesting serverless functionsLambda SnapStartActivating SnapStartHandling uniquenessRuntime hooksJavaPython.NETMonitoringSecurity modelBest practicesTroubleshootingIntegrating other servicesApache KafkaConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTroubleshootingAPI GatewayTutorialErrorsSelect an HTTP invoke method for LambdaInfrastructure ComposerCloudFormationAmazon DocumentDBTutorialDynamoDBCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialEC2Elastic Load Balancing (Application Load Balancer)Invoke using an EventBridge SchedulerIoTKinesis Data StreamsCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialMQConfigure event sourceParametersEvent filteringTroubleshootMSKConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTutorialRDSS3Tutorial: Use an S3 triggerTutorial: Use an Amazon S3 trigger to create thumbnailsSQSCreate mappingScaling behaviorError handlingParametersEvent filteringTutorialSQS cross-account tutorialS3 BatchSNSTutorialLambda permissionsExecution role (permissions for functions to access other resources)Update execution roleAWS managed policiesSource function ARNAccess permissions (permissions for other entities to access your functions)Identity-based policiesFunction accessLayer accessResource-based policiesFunction access for AWS servicesFunction access for AWS OrganizationsFunction access for other accountsLayer access for other accountsAttribute-based access controlSecure your functions by tagResources and ConditionsSecurity, governance, and complianceData protectionEncryption at restIdentity and Access ManagementHow AWS Lambda works with IAMIdentity-based policy examplesAWS managed policiesTroubleshootingGovernanceProactive controls with GuardProactive controls with AWS ConfigDetective controls with AWS ConfigCode signingCode scanningObservabilityCompliance validationResilienceInfrastructure securityCode signingCreate configurationUpdate configurationPermissionsCode signing configuration tagsMonitoring functionsFunction metricsView function metricsMetric typesFunction logsConfigure function logsView function logsCloudTrail logsAWS X-RayFunction insightsApplication SignalsLambda layersPackaging layersCreating and deleting layersAdding layersLayers with AWS CloudFormationLayers with AWS SAMLambda extensionsConfiguring extensionsExtensions partnersExtensions APITelemetry APIAPI referenceEvent schema referenceConverting events to OTel SpansLogs APITroubleshootingDeploymentInvocationExecutionNetworkingLambda applicationsMonitoring applicationsRolling deploymentsKubernetesSample applicationsWorking with AWS SDKsCode examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examplesConnecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS triggerLambda quotasOperator GuideIntroductionEvent-driven architecturesHow Lambda fits into the event-driven paradigmThe benefits of event-driven architecturesTrade-offs of event-driven architecturesDesign principlesUse services instead of custom codeUnderstanding the level of abstractionImplementing statelessness in functionsLambda function designBuilding for on-demand data instead of batchesOrchestrationDeveloping for retries and failuresAnti-patterns in Lambda-based applicationsThe Lambda monolithLambda as orchestratorRecursive patterns that cause run-away Lambda functionsLambda functions calling Lambda functionsSynchronous waiting within a single Lambda functionFrequently asked questionsApplication designUnderstanding quotasArchitecting with Service QuotasUsing multiple AWS accounts for managing quotasScaling and concurrency in LambdaChoosing and managing runtimes in Lambda functionsRuntimes and performanceMultiple runtimes in single applicationsManaging AWS SDKs in Lambda functionsNetworking and VPC configurationsComparing Lambda invocation modesUnderstanding SQS retriesControlling traffic flow for server-based resourcesFrequently asked questionsSecurityUnderstanding the Lambda execution environmentApplying the principles of least privilegeDeveloping least privilege IAM rolesAccess to CloudWatch LogsAvoiding granting wildcard permissions in IAM policiesSpecialized Lambda functions compared with all-purpose functionsSecuring workloads with public endpointsEncrypting data in Lambda-based applicationsGovernance controls with AWS CloudTrailFrequently asked questionsDebuggingStandardizing a debugging approachGeneral types of errorTroubleshooting payloadsTroubleshooting integration errorsTroubleshooting Lambda configurationsTroubleshooting queue processing by Lambda functionsIdentifying and managing throttlingErrors in the processing functionIdentifying and handling backpressureBest practices for your debugging environmentMonitoring and observabilityMonitoring concepts in Lambda-based applicationsLogging and metrics with Amazon CloudWatchHow CloudWatch structures logsImportant metrics for CloudWatchCustom metricsUsing AWS Resource Groups to organize your workloadSearching across logs with CloudWatch Logs InsightsParsing logs and structured loggingQuerying AWS-generated eventsLog visualization and dashboardsUseful Insights queriesTracing requests with AWS X-RayTroubleshooting walkthrough: isolating and resolving issuesA general approach to debugging Lambda performance issues and errorsMonitoring Lambda code storageBest practices for managing code storagePerformance optimizationLambda execution environmentsMemory and computing powerProfiling functions with AWS Lambda Power TuningOptimizing static initializationComparing the effect of global scopeStatic initialization and Provisioned ConcurrencyArchitecture and Best PracticesComparing performance of interactive and asynchronous workloadsWhen not to use a Lambda functionCost optimizationDocument historyAWS...DocumentationAWS LambdaDeveloper GuideAWSDocumentationAWS LambdaDeveloper GuideInvoking Lambda with events from other AWS services PDF RSSFocus modeOn this pageCreating a triggerServices listRelated resourcesAWS Lambda API ReferenceAWS CLI commands for AWS LambdaSDKs & Tools Did this page help you?YesNoProvide feedbackInvoking Lambda with events from other AWS services - AWS LambdaAWSDocumentationAWS LambdaDeveloper GuideCreating a triggerServices listSome AWS services can directly invoke Lambda functions using triggers. These services push events to Lambda, and the function is invoked immediately when the specified event occurs. Triggers are suitable for discrete events and real-time processing. When you create a trigger using the Lambda console, the console interacts with the corresponding AWS service to configure the event notification on that service. The trigger is actually stored and managed by the service that generates the events, not by Lambda.The events are data structured in JSON format. The JSON structure varies depending on the service that     generates it and the event type, but they all contain the data that the function needs to process the     event.A function can have multiple triggers. Each trigger acts as a client invoking your function independently, and each event that     Lambda passes to your function has data from only one trigger. Lambda converts the event document into an object and passes it to your function handler.Depending on the service, the event-driven invocation can be synchronous or asynchronous.  For synchronous invocation, the service that generates the event waits for the response from your         function. That service defines the data that the function needs to return in the response. The service         controls the error strategy, such as whether to retry on errors.  For asynchronous invocation, Lambda queues the event before passing it to your function. When Lambda         queues the event, it immediately sends a success response to the service that generated the event. After the         function processes the event, Lambda doesn\u2019t return a response to the event-generating service.  Creating a trigger The easiest way to create a trigger is to use the Lambda console. When you create a trigger using the console, Lambda automatically adds the required permissions to the function's resource-based policy. To create a trigger using the Lambda console Open the Functions page of the Lambda console.  Select the function you want to create a trigger for.  In the Function overview pane, choose           Add trigger.  Select the AWS service you want to invoke your function.  Fill out the options in the Trigger configuration pane           and choose Add. Depending on the AWS service you choose to           invoke your function, the trigger configuration options will be different.  Services that can invoke Lambda functions The following table lists services that can invoke Lambda functions.   Service Method of invocation     Amazon Managed Streaming for Apache Kafka   Event source mapping     Self-managed Apache Kafka   Event source mapping     Amazon API Gateway   Event-driven; synchronous invocation     AWS CloudFormation   Event-driven; asynchronous invocation     Amazon CloudWatch Logs   Event-driven; asynchronous invocation     AWS CodeCommit   Event-driven; asynchronous invocation     AWS CodePipeline   Event-driven; asynchronous invocation     Amazon Cognito   Event-driven; synchronous invocation     AWS Config   Event-driven; asynchronous invocation     Amazon Connect   Event-driven; synchronous invocation     Amazon DynamoDB   Event source mapping     Amazon Elastic File System   Special integration     Elastic Load Balancing (Application Load Balancer)   Event-driven; synchronous invocation     Amazon EventBridge (CloudWatch Events)   Event-driven; asynchronous invocation (event buses), synchronous or asynchronous invocation (pipes and schedules)     AWS IoT   Event-driven; asynchronous invocation     Amazon Kinesis   Event source mapping     Amazon Data Firehose   Event-driven; synchronous invocation     Amazon Lex   Event-driven; synchronous invocation     Amazon MQ   Event source mapping     Amazon Simple Email Service   Event-driven; asynchronous invocation     Amazon Simple Notification Service   Event-driven; asynchronous invocation     Amazon Simple Queue Service   Event source mapping     Amazon Simple Storage Service (Amazon S3)   Event-driven; asynchronous invocation     Amazon Simple Storage Service Batch   Event-driven; synchronous invocation     Secrets Manager   Special integration     AWS Step Functions   Event-driven; synchronous or asynchronous invocation     Amazon VPC Lattice   Event-driven; synchronous invocation     AWS X-Ray   Special integration     Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsTroubleshootingApache KafkaDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.Next topic:Apache KafkaPrevious topic:TroubleshootingNeed help?Try AWS re:Post Connect with an AWS IQ expert PrivacySite termsCookie preferences       \u00a9 2024, Amazon Web Services, Inc. or its affiliates. All rights reserved."
        ]
    },
    {
        "title": "Code examples",
        "source": "aws_lambda",
        "url": "https://docs.aws.amazon.com/lambda/latest/dg/service_code_examples.html",
        "sections": [
            "Contact UsEnglishCreate an AWS AccountFeedback Preferences AWS LambdaDeveloper GuideWhat is AWS Lambda?Create your first functionExample appsFile-processing appScheduled-maintenance appKey Lambda conceptsInfrastructure as code (IaC)Using the AWS CDKProgramming modelLambda runtimesRuntime version updatesConfiguring runtime managementRuntime version roll-backIdentifying Lambda runtime version changesShared responsibility modelPermissionsGet data about functions by runtimeRuntime modificationsRuntime APIOS-only runtimesBuilding a custom runtimeCustom runtime tutorialExecution environmentConfiguring functions.zip file archivesEncryptionContainer imagesMemoryEphemeral storageInstruction sets (ARM/x86)TimeoutEnvironment variablesSecuring environment variablesRetrieving environment variablesAttaching functions to a VPCAttaching functions to resources in another accountInternet access for VPC functionsInbound networkingFile systemAliasesUsing aliasesRouting configurationsVersionsTagsResponse streamingWriting functionsInvoking functionsTutorial: Creating a response streaming function with a function URLInvoking functionsInvoke a function synchronouslyAsynchronous invocationError handlingConfigurationRetaining recordsEvent source mappingsEvent source mapping tagsEvent filteringTesting in consoleFunction statesRetriesRecursive loop detectionFunction URLsAccess controlInvoking function URLsMonitoring function URLsSelect an HTTP invoke method for LambdaTutorial: Creating a function with a function URLFunction scalingConfiguring reserved concurrencyConfiguring provisioned concurrencyScaling behaviorMonitoring concurrencyBuilding with Node.jsHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with TypeScriptHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with PythonHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTestingTracingBuilding with RubyHandlerDeploy .zip file archivesDeploy container imagesLayersContextLoggingTracingBuilding with JavaHandlerDeploy .zip file archivesDeploy container imagesLayersCustom serializationCustom startup behaviorContextLoggingTracingSample appsBuilding with GoHandlerContextDeploy .zip file archivesDeploy container imagesLayersLoggingTracingBuilding with C#HandlerDeployment packageNET Lambda Global CLIAWS SAMAWS CDKASP.NETDeploy container imagesNative AOT compilationContextLoggingTracingTestingBuilding with PowerShellDevelopment EnvironmentDeployment packageHandlerContextLoggingBuilding with RustHandlerContextHTTP eventsDeploy .zip file archivesLoggingBest practicesTesting serverless functionsLambda SnapStartActivating SnapStartHandling uniquenessRuntime hooksJavaPython.NETMonitoringSecurity modelBest practicesTroubleshootingIntegrating other servicesApache KafkaConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTroubleshootingAPI GatewayTutorialErrorsSelect an HTTP invoke method for LambdaInfrastructure ComposerCloudFormationAmazon DocumentDBTutorialDynamoDBCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialEC2Elastic Load Balancing (Application Load Balancer)Invoke using an EventBridge SchedulerIoTKinesis Data StreamsCreate mappingBatch item failuresError handlingStateful processingParametersEvent filteringTutorialMQConfigure event sourceParametersEvent filteringTroubleshootMSKConfigure event sourceProcess messagesEvent filteringOn-failure destinationsTutorialRDSS3Tutorial: Use an S3 triggerTutorial: Use an Amazon S3 trigger to create thumbnailsSQSCreate mappingScaling behaviorError handlingParametersEvent filteringTutorialSQS cross-account tutorialS3 BatchSNSTutorialLambda permissionsExecution role (permissions for functions to access other resources)Update execution roleAWS managed policiesSource function ARNAccess permissions (permissions for other entities to access your functions)Identity-based policiesFunction accessLayer accessResource-based policiesFunction access for AWS servicesFunction access for AWS OrganizationsFunction access for other accountsLayer access for other accountsAttribute-based access controlSecure your functions by tagResources and ConditionsSecurity, governance, and complianceData protectionEncryption at restIdentity and Access ManagementHow AWS Lambda works with IAMIdentity-based policy examplesAWS managed policiesTroubleshootingGovernanceProactive controls with GuardProactive controls with AWS ConfigDetective controls with AWS ConfigCode signingCode scanningObservabilityCompliance validationResilienceInfrastructure securityCode signingCreate configurationUpdate configurationPermissionsCode signing configuration tagsMonitoring functionsFunction metricsView function metricsMetric typesFunction logsConfigure function logsView function logsCloudTrail logsAWS X-RayFunction insightsApplication SignalsLambda layersPackaging layersCreating and deleting layersAdding layersLayers with AWS CloudFormationLayers with AWS SAMLambda extensionsConfiguring extensionsExtensions partnersExtensions APITelemetry APIAPI referenceEvent schema referenceConverting events to OTel SpansLogs APITroubleshootingDeploymentInvocationExecutionNetworkingLambda applicationsMonitoring applicationsRolling deploymentsKubernetesSample applicationsWorking with AWS SDKsCode examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examplesConnecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS triggerLambda quotasOperator GuideIntroductionEvent-driven architecturesHow Lambda fits into the event-driven paradigmThe benefits of event-driven architecturesTrade-offs of event-driven architecturesDesign principlesUse services instead of custom codeUnderstanding the level of abstractionImplementing statelessness in functionsLambda function designBuilding for on-demand data instead of batchesOrchestrationDeveloping for retries and failuresAnti-patterns in Lambda-based applicationsThe Lambda monolithLambda as orchestratorRecursive patterns that cause run-away Lambda functionsLambda functions calling Lambda functionsSynchronous waiting within a single Lambda functionFrequently asked questionsApplication designUnderstanding quotasArchitecting with Service QuotasUsing multiple AWS accounts for managing quotasScaling and concurrency in LambdaChoosing and managing runtimes in Lambda functionsRuntimes and performanceMultiple runtimes in single applicationsManaging AWS SDKs in Lambda functionsNetworking and VPC configurationsComparing Lambda invocation modesUnderstanding SQS retriesControlling traffic flow for server-based resourcesFrequently asked questionsSecurityUnderstanding the Lambda execution environmentApplying the principles of least privilegeDeveloping least privilege IAM rolesAccess to CloudWatch LogsAvoiding granting wildcard permissions in IAM policiesSpecialized Lambda functions compared with all-purpose functionsSecuring workloads with public endpointsEncrypting data in Lambda-based applicationsGovernance controls with AWS CloudTrailFrequently asked questionsDebuggingStandardizing a debugging approachGeneral types of errorTroubleshooting payloadsTroubleshooting integration errorsTroubleshooting Lambda configurationsTroubleshooting queue processing by Lambda functionsIdentifying and managing throttlingErrors in the processing functionIdentifying and handling backpressureBest practices for your debugging environmentMonitoring and observabilityMonitoring concepts in Lambda-based applicationsLogging and metrics with Amazon CloudWatchHow CloudWatch structures logsImportant metrics for CloudWatchCustom metricsUsing AWS Resource Groups to organize your workloadSearching across logs with CloudWatch Logs InsightsParsing logs and structured loggingQuerying AWS-generated eventsLog visualization and dashboardsUseful Insights queriesTracing requests with AWS X-RayTroubleshooting walkthrough: isolating and resolving issuesA general approach to debugging Lambda performance issues and errorsMonitoring Lambda code storageBest practices for managing code storagePerformance optimizationLambda execution environmentsMemory and computing powerProfiling functions with AWS Lambda Power TuningOptimizing static initializationComparing the effect of global scopeStatic initialization and Provisioned ConcurrencyArchitecture and Best PracticesComparing performance of interactive and asynchronous workloadsWhen not to use a Lambda functionCost optimizationDocument historyAWS...DocumentationAWS LambdaDeveloper GuideAWSDocumentationAWS LambdaDeveloper GuideCode examples for Lambda using AWS SDKs PDF RSSFocus modeRelated resourcesAWS Lambda API ReferenceAWS CLI commands for AWS LambdaSDKs & Tools Did this page help you?YesNoProvide feedbackCode examples for Lambda using AWS SDKs - AWS LambdaAWSDocumentationAWS LambdaDeveloper GuideThe following code examples show how to use Lambda with an AWS software development kit (SDK).         Basics are code examples that show you how to perform the essential operations within a service.Actions are code excerpts from larger programs and must be run in context. While actions     show you how to call individual service functions, you can see actions in context in their related scenarios.Scenarios are code examples that show you how to accomplish specific tasks by     calling multiple functions within a service or combined with other AWS services. For a complete list of AWS SDK developer guides and code examples, see     Using Lambda with an AWS SDK.     This topic also includes information about getting started and details about previous SDK versions.Get started The following code examples show how to get started using Lambda. .NET   AWS SDK for .NET  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      namespace LambdaActions;  using Amazon.Lambda;  public class HelloLambda {     static async Task Main(string[] args)     {         var lambdaClient = new AmazonLambdaClient();          Console.WriteLine(\"Hello AWS Lambda\");         Console.WriteLine(\"Let's get started with AWS Lambda by listing your existing Lambda functions:\");          var response = await lambdaClient.ListFunctionsAsync();         response.Functions.ForEach(function =>         {             Console.WriteLine($\"{function.FunctionName}\\t{function.Description}\");         });     } }                               For API details, see                         ListFunctions                         in AWS SDK for .NET API Reference.                          C++   SDK for C++  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      Code for the CMakeLists.txt CMake file. # Set the minimum required version of CMake for this project. cmake_minimum_required(VERSION 3.13)  # Set the AWS service components used by this project. set(SERVICE_COMPONENTS lambda)  # Set this project's name. project(\"hello_lambda\")  # Set the C++ standard to use to build this target. # At least C++ 11 is required for the AWS SDK for C++. set(CMAKE_CXX_STANDARD 11)  # Use the MSVC variable to determine if this is a Windows build. set(WINDOWS_BUILD ${MSVC})  if (WINDOWS_BUILD) # Set the location where CMake can find the installed libraries for the AWS SDK.     string(REPLACE \";\" \"/aws-cpp-sdk-all;\" SYSTEM_MODULE_PATH \"${CMAKE_SYSTEM_PREFIX_PATH}/aws-cpp-sdk-all\")     list(APPEND CMAKE_PREFIX_PATH ${SYSTEM_MODULE_PATH}) endif ()  # Find the AWS SDK for C++ package. find_package(AWSSDK REQUIRED COMPONENTS ${SERVICE_COMPONENTS})  if (WINDOWS_BUILD AND AWSSDK_INSTALL_AS_SHARED_LIBS)      # Copy relevant AWS SDK for C++ libraries into the current binary directory for running and debugging.       # set(BIN_SUB_DIR \"/Debug\") # if you are building from the command line you may need to uncomment this                                      # and set the proper subdirectory to the executables' location.       AWSSDK_CPY_DYN_LIBS(SERVICE_COMPONENTS \"\" ${CMAKE_CURRENT_BINARY_DIR}${BIN_SUB_DIR}) endif ()  add_executable(${PROJECT_NAME}         hello_lambda.cpp)  target_link_libraries(${PROJECT_NAME}         ${AWSSDK_LINK_LIBRARIES})   Code for the hello_lambda.cpp source file. #include <aws/core/Aws.h> #include <aws/lambda/LambdaClient.h> #include <aws/lambda/model/ListFunctionsRequest.h> #include <iostream>  /*  *  A \"Hello Lambda\" starter application which initializes an AWS Lambda (Lambda) client and lists the Lambda functions.  *  *  main function  *  *  Usage: 'hello_lambda'  *  */  int main(int argc, char **argv) {     Aws::SDKOptions options;     // Optionally change the log level for debugging. //   options.loggingOptions.logLevel = Utils::Logging::LogLevel::Debug;     Aws::InitAPI(options); // Should only be called once.     int result = 0;     {         Aws::Client::ClientConfiguration clientConfig;         // Optional: Set to the AWS Region (overrides config file).         // clientConfig.region = \"us-east-1\";          Aws::Lambda::LambdaClient lambdaClient(clientConfig);         std::vector<Aws::String> functions;         Aws::String marker; // Used for pagination.          do {             Aws::Lambda::Model::ListFunctionsRequest request;             if (!marker.empty()) {                 request.SetMarker(marker);             }              Aws::Lambda::Model::ListFunctionsOutcome outcome = lambdaClient.ListFunctions(                     request);              if (outcome.IsSuccess()) {                 const Aws::Lambda::Model::ListFunctionsResult &listFunctionsResult = outcome.GetResult();                 std::cout << listFunctionsResult.GetFunctions().size()                           << \" lambda functions were retrieved.\" << std::endl;                  for (const Aws::Lambda::Model::FunctionConfiguration &functionConfiguration: listFunctionsResult.GetFunctions()) {                     functions.push_back(functionConfiguration.GetFunctionName());                     std::cout << functions.size() << \"  \"                               << functionConfiguration.GetDescription() << std::endl;                     std::cout << \"   \"                               << Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime(                                       functionConfiguration.GetRuntime()) << \": \"                               << functionConfiguration.GetHandler()                               << std::endl;                 }                 marker = listFunctionsResult.GetNextMarker();             } else {                 std::cerr << \"Error with Lambda::ListFunctions. \"                           << outcome.GetError().GetMessage()                           << std::endl;                 result = 1;                 break;             }         } while (!marker.empty());     }       Aws::ShutdownAPI(options); // Should only be called once.     return result; }                              For API details, see                         ListFunctions                         in AWS SDK for C++ API Reference.                          Go   SDK for Go V2  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       package main  import ( \t\"context\" \t\"fmt\"  \t\"github.com/aws/aws-sdk-go-v2/aws\" \t\"github.com/aws/aws-sdk-go-v2/config\" \t\"github.com/aws/aws-sdk-go-v2/service/lambda\" )  // main uses the AWS SDK for Go (v2) to create an AWS Lambda client and list up to 10 // functions in your account. // This example uses the default settings specified in your shared credentials // and config files. func main() { \tctx := context.Background() \tsdkConfig, err := config.LoadDefaultConfig(ctx) \tif err != nil { \t\tfmt.Println(\"Couldn't load default configuration. Have you set up your AWS account?\") \t\tfmt.Println(err) \t\treturn \t} \tlambdaClient := lambda.NewFromConfig(sdkConfig)  \tmaxItems := 10 \tfmt.Printf(\"Let's list up to %v functions for your account. \", maxItems) \tresult, err := lambdaClient.ListFunctions(ctx, &lambda.ListFunctionsInput{ \t\tMaxItems: aws.Int32(int32(maxItems)), \t}) \tif err != nil { \t\tfmt.Printf(\"Couldn't list functions for your account. Here's why: %v \", err) \t\treturn \t} \tif len(result.Functions) == 0 { \t\tfmt.Println(\"You don't have any functions!\") \t} else { \t\tfor _, function := range result.Functions { \t\t\tfmt.Printf(\"\\t%v \", *function.FunctionName) \t\t} \t} }                               For API details, see                         ListFunctions                         in AWS SDK for Go API Reference.                          Java   SDK for Java 2.x  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.          /**      * Lists the AWS Lambda functions associated with the current AWS account.      *      * @param awsLambda an instance of the {@link LambdaClient} class, which is used to interact with the AWS Lambda service      *      * @throws LambdaException if an error occurs while interacting with the AWS Lambda service      */     public static void listFunctions(LambdaClient awsLambda) {         try {             ListFunctionsResponse functionResult = awsLambda.listFunctions();             List<FunctionConfiguration> list = functionResult.functions();             for (FunctionConfiguration config : list) {                 System.out.println(\"The function name is \" + config.functionName());             }          } catch (LambdaException e) {             System.err.println(e.getMessage());             System.exit(1);         }     }                              For API details, see                         ListFunctions                         in AWS SDK for Java 2.x API Reference.                          JavaScript   SDK for JavaScript (v3)  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      import { LambdaClient, paginateListFunctions } from \"@aws-sdk/client-lambda\";  const client = new LambdaClient({});  export const helloLambda = async () => {   const paginator = paginateListFunctions({ client }, {});   const functions = [];    for await (const page of paginator) {     const funcNames = page.Functions.map((f) => f.FunctionName);     functions.push(...funcNames);   }    console.log(\"Functions:\");   console.log(functions.join(\" \"));   return functions; };                              For API details, see                         ListFunctions                         in AWS SDK for JavaScript API Reference.                          Python   SDK for Python (Boto3)  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       import boto3   def main():     \"\"\"     List the Lambda functions in your AWS account.     \"\"\"     # Create the Lambda client     lambda_client = boto3.client(\"lambda\")      # Use the paginator to list the functions     paginator = lambda_client.get_paginator(\"list_functions\")     response_iterator = paginator.paginate()      print(\"Here are the Lambda functions in your account:\")     for page in response_iterator:         for function in page[\"Functions\"]:             print(f\"  {function['FunctionName']}\")   if __name__ == \"__main__\":     main()                               For API details, see                         ListFunctions                         in AWS SDK for Python (Boto3) API Reference.                          Ruby   SDK for Ruby  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       require 'aws-sdk-lambda'  # Creates an AWS Lambda client using the default credentials and configuration def lambda_client   Aws::Lambda::Client.new end  # Lists the Lambda functions in your AWS account, paginating the results if necessary def list_lambda_functions   lambda = lambda_client    # Use a pagination iterator to list all functions   functions = []   lambda.list_functions.each_page do |page|     functions.concat(page.functions)   end    # Print the name and ARN of each function   functions.each do |function|     puts \"Function name: #{function.function_name}\"     puts \"Function ARN: #{function.function_arn}\"     puts   end    puts \"Total functions: #{functions.count}\" end  list_lambda_functions if __FILE__ == $PROGRAM_NAME                               For API details, see                         ListFunctions                         in AWS SDK for Ruby API Reference.                          Hello LambdaThe following code examples show how to get started using Lambda. .NET   AWS SDK for .NET  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      namespace LambdaActions;  using Amazon.Lambda;  public class HelloLambda {     static async Task Main(string[] args)     {         var lambdaClient = new AmazonLambdaClient();          Console.WriteLine(\"Hello AWS Lambda\");         Console.WriteLine(\"Let's get started with AWS Lambda by listing your existing Lambda functions:\");          var response = await lambdaClient.ListFunctionsAsync();         response.Functions.ForEach(function =>         {             Console.WriteLine($\"{function.FunctionName}\\t{function.Description}\");         });     } }                               For API details, see                         ListFunctions                         in AWS SDK for .NET API Reference.                          C++   SDK for C++  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      Code for the CMakeLists.txt CMake file. # Set the minimum required version of CMake for this project. cmake_minimum_required(VERSION 3.13)  # Set the AWS service components used by this project. set(SERVICE_COMPONENTS lambda)  # Set this project's name. project(\"hello_lambda\")  # Set the C++ standard to use to build this target. # At least C++ 11 is required for the AWS SDK for C++. set(CMAKE_CXX_STANDARD 11)  # Use the MSVC variable to determine if this is a Windows build. set(WINDOWS_BUILD ${MSVC})  if (WINDOWS_BUILD) # Set the location where CMake can find the installed libraries for the AWS SDK.     string(REPLACE \";\" \"/aws-cpp-sdk-all;\" SYSTEM_MODULE_PATH \"${CMAKE_SYSTEM_PREFIX_PATH}/aws-cpp-sdk-all\")     list(APPEND CMAKE_PREFIX_PATH ${SYSTEM_MODULE_PATH}) endif ()  # Find the AWS SDK for C++ package. find_package(AWSSDK REQUIRED COMPONENTS ${SERVICE_COMPONENTS})  if (WINDOWS_BUILD AND AWSSDK_INSTALL_AS_SHARED_LIBS)      # Copy relevant AWS SDK for C++ libraries into the current binary directory for running and debugging.       # set(BIN_SUB_DIR \"/Debug\") # if you are building from the command line you may need to uncomment this                                      # and set the proper subdirectory to the executables' location.       AWSSDK_CPY_DYN_LIBS(SERVICE_COMPONENTS \"\" ${CMAKE_CURRENT_BINARY_DIR}${BIN_SUB_DIR}) endif ()  add_executable(${PROJECT_NAME}         hello_lambda.cpp)  target_link_libraries(${PROJECT_NAME}         ${AWSSDK_LINK_LIBRARIES})   Code for the hello_lambda.cpp source file. #include <aws/core/Aws.h> #include <aws/lambda/LambdaClient.h> #include <aws/lambda/model/ListFunctionsRequest.h> #include <iostream>  /*  *  A \"Hello Lambda\" starter application which initializes an AWS Lambda (Lambda) client and lists the Lambda functions.  *  *  main function  *  *  Usage: 'hello_lambda'  *  */  int main(int argc, char **argv) {     Aws::SDKOptions options;     // Optionally change the log level for debugging. //   options.loggingOptions.logLevel = Utils::Logging::LogLevel::Debug;     Aws::InitAPI(options); // Should only be called once.     int result = 0;     {         Aws::Client::ClientConfiguration clientConfig;         // Optional: Set to the AWS Region (overrides config file).         // clientConfig.region = \"us-east-1\";          Aws::Lambda::LambdaClient lambdaClient(clientConfig);         std::vector<Aws::String> functions;         Aws::String marker; // Used for pagination.          do {             Aws::Lambda::Model::ListFunctionsRequest request;             if (!marker.empty()) {                 request.SetMarker(marker);             }              Aws::Lambda::Model::ListFunctionsOutcome outcome = lambdaClient.ListFunctions(                     request);              if (outcome.IsSuccess()) {                 const Aws::Lambda::Model::ListFunctionsResult &listFunctionsResult = outcome.GetResult();                 std::cout << listFunctionsResult.GetFunctions().size()                           << \" lambda functions were retrieved.\" << std::endl;                  for (const Aws::Lambda::Model::FunctionConfiguration &functionConfiguration: listFunctionsResult.GetFunctions()) {                     functions.push_back(functionConfiguration.GetFunctionName());                     std::cout << functions.size() << \"  \"                               << functionConfiguration.GetDescription() << std::endl;                     std::cout << \"   \"                               << Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime(                                       functionConfiguration.GetRuntime()) << \": \"                               << functionConfiguration.GetHandler()                               << std::endl;                 }                 marker = listFunctionsResult.GetNextMarker();             } else {                 std::cerr << \"Error with Lambda::ListFunctions. \"                           << outcome.GetError().GetMessage()                           << std::endl;                 result = 1;                 break;             }         } while (!marker.empty());     }       Aws::ShutdownAPI(options); // Should only be called once.     return result; }                              For API details, see                         ListFunctions                         in AWS SDK for C++ API Reference.                          Go   SDK for Go V2  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       package main  import ( \t\"context\" \t\"fmt\"  \t\"github.com/aws/aws-sdk-go-v2/aws\" \t\"github.com/aws/aws-sdk-go-v2/config\" \t\"github.com/aws/aws-sdk-go-v2/service/lambda\" )  // main uses the AWS SDK for Go (v2) to create an AWS Lambda client and list up to 10 // functions in your account. // This example uses the default settings specified in your shared credentials // and config files. func main() { \tctx := context.Background() \tsdkConfig, err := config.LoadDefaultConfig(ctx) \tif err != nil { \t\tfmt.Println(\"Couldn't load default configuration. Have you set up your AWS account?\") \t\tfmt.Println(err) \t\treturn \t} \tlambdaClient := lambda.NewFromConfig(sdkConfig)  \tmaxItems := 10 \tfmt.Printf(\"Let's list up to %v functions for your account. \", maxItems) \tresult, err := lambdaClient.ListFunctions(ctx, &lambda.ListFunctionsInput{ \t\tMaxItems: aws.Int32(int32(maxItems)), \t}) \tif err != nil { \t\tfmt.Printf(\"Couldn't list functions for your account. Here's why: %v \", err) \t\treturn \t} \tif len(result.Functions) == 0 { \t\tfmt.Println(\"You don't have any functions!\") \t} else { \t\tfor _, function := range result.Functions { \t\t\tfmt.Printf(\"\\t%v \", *function.FunctionName) \t\t} \t} }                               For API details, see                         ListFunctions                         in AWS SDK for Go API Reference.                          Java   SDK for Java 2.x  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.          /**      * Lists the AWS Lambda functions associated with the current AWS account.      *      * @param awsLambda an instance of the {@link LambdaClient} class, which is used to interact with the AWS Lambda service      *      * @throws LambdaException if an error occurs while interacting with the AWS Lambda service      */     public static void listFunctions(LambdaClient awsLambda) {         try {             ListFunctionsResponse functionResult = awsLambda.listFunctions();             List<FunctionConfiguration> list = functionResult.functions();             for (FunctionConfiguration config : list) {                 System.out.println(\"The function name is \" + config.functionName());             }          } catch (LambdaException e) {             System.err.println(e.getMessage());             System.exit(1);         }     }                              For API details, see                         ListFunctions                         in AWS SDK for Java 2.x API Reference.                          JavaScript   SDK for JavaScript (v3)  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      import { LambdaClient, paginateListFunctions } from \"@aws-sdk/client-lambda\";  const client = new LambdaClient({});  export const helloLambda = async () => {   const paginator = paginateListFunctions({ client }, {});   const functions = [];    for await (const page of paginator) {     const funcNames = page.Functions.map((f) => f.FunctionName);     functions.push(...funcNames);   }    console.log(\"Functions:\");   console.log(functions.join(\" \"));   return functions; };                              For API details, see                         ListFunctions                         in AWS SDK for JavaScript API Reference.                          Python   SDK for Python (Boto3)  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       import boto3   def main():     \"\"\"     List the Lambda functions in your AWS account.     \"\"\"     # Create the Lambda client     lambda_client = boto3.client(\"lambda\")      # Use the paginator to list the functions     paginator = lambda_client.get_paginator(\"list_functions\")     response_iterator = paginator.paginate()      print(\"Here are the Lambda functions in your account:\")     for page in response_iterator:         for function in page[\"Functions\"]:             print(f\"  {function['FunctionName']}\")   if __name__ == \"__main__\":     main()                               For API details, see                         ListFunctions                         in AWS SDK for Python (Boto3) API Reference.                          Ruby   SDK for Ruby  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.       require 'aws-sdk-lambda'  # Creates an AWS Lambda client using the default credentials and configuration def lambda_client   Aws::Lambda::Client.new end  # Lists the Lambda functions in your AWS account, paginating the results if necessary def list_lambda_functions   lambda = lambda_client    # Use a pagination iterator to list all functions   functions = []   lambda.list_functions.each_page do |page|     functions.concat(page.functions)   end    # Print the name and ARN of each function   functions.each do |function|     puts \"Function name: #{function.function_name}\"     puts \"Function ARN: #{function.function_arn}\"     puts   end    puts \"Total functions: #{functions.count}\" end  list_lambda_functions if __FILE__ == $PROGRAM_NAME                               For API details, see                         ListFunctions                         in AWS SDK for Ruby API Reference.                          anchoranchoranchoranchoranchoranchoranchor.NETC++GoJavaJavaScriptPythonRuby   AWS SDK for .NET  Note         There's more on GitHub. Find the complete example and learn how to set up and run in the         AWS Code             Examples Repository.      namespace LambdaActions;  using Amazon.Lambda;  public class HelloLambda {     static async Task Main(string[] args)     {         var lambdaClient = new AmazonLambdaClient();          Console.WriteLine(\"Hello AWS Lambda\");         Console.WriteLine(\"Let's get started with AWS Lambda by listing your existing Lambda functions:\");          var response = await lambdaClient.ListFunctionsAsync();         response.Functions.ForEach(function =>         {             Console.WriteLine($\"{function.FunctionName}\\t{function.Description}\");         });     } }                               For API details, see                         ListFunctions                         in AWS SDK for .NET API Reference.                          Code examplesBasicsHello LambdaLearn the basicsActionsCreateAliasCreateFunctionDeleteAliasDeleteFunctionDeleteFunctionConcurrencyDeleteProvisionedConcurrencyConfigGetAccountSettingsGetAliasGetFunctionGetFunctionConcurrencyGetFunctionConfigurationGetPolicyGetProvisionedConcurrencyConfigInvokeListFunctionsListProvisionedConcurrencyConfigsListTagsListVersionsByFunctionPublishVersionPutFunctionConcurrencyPutProvisionedConcurrencyConfigRemovePermissionTagResourceUntagResourceUpdateAliasUpdateFunctionCodeUpdateFunctionConfigurationScenariosAutomatically confirm known users with a Lambda functionAutomatically migrate known users with a Lambda functionCreate a REST API to track COVID-19 dataCreate a lending library REST APICreate a messenger applicationCreate a serverless application to manage photosCreate a websocket chat applicationCreate an application to analyze customer feedbackInvoke a Lambda function from a browserTransform data with S3 Object LambdaUse API Gateway to invoke a Lambda functionUse Step Functions to invoke Lambda functionsUse scheduled events to invoke a Lambda functionWrite custom activity data with a Lambda function after Amazon Cognito user authenticationServerless examples         Connecting to an Amazon RDS database in a Lambda functionInvoke a Lambda function from a Kinesis triggerInvoke a Lambda function from a DynamoDB triggerInvoke a Lambda function from a Amazon DocumentDB triggerInvoke a Lambda function from an Amazon MSK triggerInvoke a Lambda function from an Amazon S3 triggerInvoke a Lambda function from an Amazon SNS triggerInvoke a Lambda function from an Amazon SQS triggerReporting batch item failures for Lambda functions with a Kinesis triggerReporting batch item failures for Lambda functions with a DynamoDB triggerReporting batch item failures for Lambda functions with an Amazon SQS trigger Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsWorking with AWS SDKsBasicsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.Next topic:BasicsPrevious topic:Working with AWS SDKsNeed help?Try AWS re:Post Connect with an AWS IQ expert PrivacySite termsCookie preferences       \u00a9 2024, Amazon Web Services, Inc. or its affiliates. All rights reserved."
        ]
    }
]